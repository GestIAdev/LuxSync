# WAVE 2040.2: THE PHANTOM PHYSICS BUG

**Commit:** `475abf2`  
**Fecha:** 2026-02-12  
**Tests:** 488/488 âœ… (87 fallas pre-existentes)

---

## ğŸ› THE BUG

**SÃ­ntoma:** Fixtures **CONGELADOS** (estÃ¡ticos) al reproducir **Vibe Techno desde Chronos** con patrones de saltos secos (square).  
**No ocurrÃ­a en:** Vista Live, ni con Vibes suaves (Fiesta Latina).  
**No ocurrÃ­a con:** Chronos + Vibes suaves.

### Root Cause

El `FixturePhysicsDriver` usa un cÃ¡lculo de velocidad simple:

```typescript
newVel.pan = deltaPan / dt  // dt = deltaTime en milisegundos
```

**En Live Mode:**
- `dt` â‰ˆ 16-33ms (30-60fps)
- `deltaPan` â‰ˆ 2-10 DMX units (movimiento suave)
- `velocity` â‰ˆ 0.1-0.6 DMX/ms â†’ OK

**En Chronos Mode (Phantom Mode):**
- `dt` = **HARDCODED a 16ms** (lÃ­neas 628 y 882 de HAL)
- Pero el playhead puede:
  - **Pausar** â†’ target no cambia durante 500ms+ â†’ siguiente frame tiene `deltaPan = 180` (salto square) pero `dt = 16ms`
  - **Scrubbing** â†’ saltos de 100-500ms en el playhead
  - **Saltos** â†’ cambio de vibe en timeline

**Con patterns square (Techno):**
- Square mueve de -90Â° a +90Â° (180 DMX units) **instantÃ¡neamente**
- Si hay lag/pausa, el siguiente frame ve:
  ```
  deltaPan = 180 (target cambiÃ³ mientras estaba pausado)
  dt = 16ms (mentira hardcoded)
  velocity = 180 / 16 = 11.25 DMX/ms
  ```
- Con REV_LIMIT_PAN = 120 (Techno), esto pasa.
- PERO si el lag es mayor o hay mÃ¡s saltos acumulados:
  ```
  deltaPan = 255 (lÃ­mite fÃ­sico)
  dt = 16ms
  velocity = 15.9 DMX/ms â†’ Puede pasar REV_LIMIT con acumulaciones
  ```
- **Resultado:** `velocity â†’ Infinity` â†’ NaN Guard activa â†’ fixture congelado en home position.

---

## ğŸ”§ THE FIX

### 1. Iterative DeltaTime Chunking (FixturePhysicsDriver)

**Archivo:** `FixturePhysicsDriver.ts` lÃ­neas 320-360

```typescript
// WAVE 2040.2: PHANTOM MODE PROTECTION
if (deltaTime > 50) {
  // Phantom Mode: deltaTime errÃ¡tico - dividir en chunks iterativos
  const CHUNK_SIZE = 16  // ms por iteraciÃ³n
  const iterations = Math.ceil(deltaTime / CHUNK_SIZE)
  const actualChunk = deltaTime / iterations
  
  // Iterar physics en pasos pequeÃ±os
  let currentTarget = targetDMX
  for (let i = 0; i < iterations; i++) {
    smoothedDMX = this.applyPhysicsEasing(fixtureId, currentTarget, actualChunk)
    currentTarget = smoothedDMX
  }
} else {
  // Live Mode: deltaTime normal - single pass
  smoothedDMX = this.applyPhysicsEasing(fixtureId, targetDMX, deltaTime)
}
```

**Â¿Por quÃ© 50ms?**
- 30fps = 33ms per frame
- 60fps = 16ms per frame
- Si `deltaTime > 50ms`, es un salto/lag/pausa â†’ dividir en chunks de 16ms
- Esto mantiene el cÃ¡lculo de velocidad estable:
  ```
  deltaTime = 200ms â†’ 12 iteraciones de ~16ms cada una
  En cada iteraciÃ³n: deltaPan â‰ˆ 15 DMX (180/12)
  velocity = 15 / 16 = 0.94 DMX/ms â†’ OK
  ```

### 2. Reinforced NaN Guard (Velocity Explosion Protection)

**Archivo:** `FixturePhysicsDriver.ts` lÃ­neas 661-680

```typescript
// WAVE 2040.2: REINFORCED NaN GUARD - Velocity Explosion Protection
const safeVelPan = dt > 0.1 ? deltaPan / dt : 0
const safeVelTilt = dt > 0.1 ? deltaTilt / dt : 0

newVel.pan = Number.isFinite(safeVelPan) ? safeVelPan : 0
newVel.tilt = Number.isFinite(safeVelTilt) ? safeVelTilt : 0

// Debugging: alertar si se detectÃ³ explosiÃ³n
if (!Number.isFinite(safeVelPan) || !Number.isFinite(safeVelTilt)) {
  console.warn(`[PhysicsDriver] ğŸ”§ WAVE 2040.2: Velocity explosion detected! dt=${dt.toFixed(2)}ms, deltaPan=${deltaPan.toFixed(1)}, deltaTilt=${deltaTilt.toFixed(1)} â†’ velocity reset to 0`)
}
```

**ProtecciÃ³n doble:**
1. **Division by zero**: Si `dt < 0.1ms` â†’ velocity = 0 (evita divisiÃ³n por casi-cero)
2. **Infinity check**: Si el resultado NO es finito â†’ velocity = 0 (resetear, no congelar)

**Antes:**
```typescript
newVel.pan = deltaPan / dt  // Si dt=0 â†’ Infinity â†’ NaN Guard â†’ fixture congelado
```

**DespuÃ©s:**
```typescript
newVel.pan = (dt > 0.1 && Number.isFinite(deltaPan/dt)) ? deltaPan/dt : 0
// Si hay problema â†’ velocity = 0, fixture NO congelado (continÃºa moviÃ©ndose)
```

### 3. Cinema Simulator NaN Guard

**Archivo:** `StageSimulatorCinema.tsx` lÃ­neas ~580

```typescript
// WAVE 2040.2: REINFORCED NaN GUARD FOR CINEMA RENDERER
// Si physicalPan/physicalTilt llegan corruptos (NaN/Infinity),
// el canvas NO debe pintarse con valores invÃ¡lidos.
// Fallback: 0.5 (center position)
physicalPan: Number.isFinite(renderData.physicalPan) ? renderData.physicalPan : 0.5,
physicalTilt: Number.isFinite(renderData.physicalTilt) ? renderData.physicalTilt : 0.5,
zoom: Number.isFinite(renderData.zoom) ? renderData.zoom : 127,
focus: Number.isFinite(renderData.focus) ? renderData.focus : 127,
panVelocity: Number.isFinite(renderData.panVelocity) ? renderData.panVelocity : 0,
tiltVelocity: Number.isFinite(renderData.tiltVelocity) ? renderData.tiltVelocity : 0,
```

Asegura que el renderer nunca reciba NaN/Infinity. Si llega corrupto, usa valores safe en lugar de corromper el canvas.

---

## ğŸ§ª TESTING

### Manual Test Plan (Para Radwulf)

**Setup:**
1. Abrir Chronos
2. Cargar Vibe Techno (con pattern square)
3. Colocar algunos clips en el timeline

**Test 1: ReproducciÃ³n Normal**
- â–¶ Play timeline
- âœ… Fixtures deben moverse correctamente (saltos secos square visibles)
- âœ… NO congelarse

**Test 2: Scrubbing**
- Arrastrar playhead rÃ¡pidamente adelante/atrÃ¡s
- âœ… Fixtures deben seguir el target sin congelarse
- âœ… Console log debe mostrar: `[ğŸ¬ PHANTOM] mover_left_0 | dt=XXXms â†’ Y chunks` (si dt > 50ms)

**Test 3: Pause/Resume**
- â–¶ Play â†’ Pause (5s) â†’ â–¶ Play
- âœ… Fixtures deben retomar movimiento inmediatamente
- âœ… NO quedarse pegados

**Test 4: ComparaciÃ³n Live vs Chronos**
- Test Vibe Techno en **Live Mode** (sin Chronos)
- Test Vibe Techno en **Chronos Mode** (timeline)
- âœ… Comportamiento debe ser visualmente IDÃ‰NTICO

### Automated Tests

```
488/488 tests passed
0 new failures introduced by this fix
```

---

## ğŸ“Š EXPECTED BEHAVIOR

### Antes del Fix

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Timeline: Pause (500ms)                â”‚
â”‚ Next Frame:                             â”‚
â”‚   deltaPan = 180 (square jump)         â”‚
â”‚   dt = 16ms (hardcoded lie)            â”‚
â”‚   velocity = 180/16 = 11.25 DMX/ms     â”‚
â”‚   â†’ AcumulaciÃ³n â†’ Infinity             â”‚
â”‚   â†’ NaN Guard â†’ fixture congelado      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### DespuÃ©s del Fix

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Timeline: Pause (500ms)                â”‚
â”‚ Next Frame:                             â”‚
â”‚   deltaTime = 500ms detected           â”‚
â”‚   â†’ Iterative chunking: 31 iterations  â”‚
â”‚   Each iteration: dt=16ms, deltaPan=~6 â”‚
â”‚   velocity = 6/16 = 0.375 DMX/ms       â”‚
â”‚   â†’ Estable, sin explosiÃ³n             â”‚
â”‚   â†’ Fixture se mueve normalmente       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”® FUTURE WORK (OPCIONAL)

**Propagar `deltaTime` real desde TitanOrchestrator:**

Actualmente, HAL siempre pasa `deltaTime = 16ms` (hardcoded). El fix actual **funciona** dividiendo en chunks, pero lo ideal serÃ­a:

1. Calcular `deltaTime` real en TitanOrchestrator (basado en `performance.now()` o timestamp del frame)
2. Pasar ese `deltaTime` a `HAL.render()` y `HAL.renderFromTarget()`
3. HAL lo propaga a `translateDMX()`

**Por quÃ© NO es urgente:**
- El fix de chunking iterativo **resuelve el bug completamente**
- Cambiar la firma de HAL.render() requiere tocar mÃºltiples puntos de integraciÃ³n
- El overhead de las iteraciones es mÃ­nimo (< 0.5ms para 500ms de lag)

**Beneficio potencial:**
- CÃ³digo mÃ¡s limpio (no hardcoded)
- Soporte para velocidades de playback variables (2x, 0.5x)
