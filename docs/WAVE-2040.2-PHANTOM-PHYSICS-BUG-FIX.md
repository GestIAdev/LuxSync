# WAVE 2040.2: THE PHANTOM PHYSICS BUG

**Commit:** `475abf2` (initial fix), `71d0acf` (anti-freeze)  
**Fecha:** 2026-02-12  
**Tests:** 488/488 âœ… (87 fallas pre-existentes)

---

## ðŸ› THE BUG

**SÃ­ntoma:** Fixtures **CONGELADOS** (estÃ¡ticos) al reproducir **Vibe Techno desde Chronos** con patrones de saltos secos (square).  
**No ocurrÃ­a en:** Vista Live, ni con Vibes suaves (Fiesta Latina).  
**No ocurrÃ­a con:** Chronos + Vibes suaves.

### Root Cause

El `FixturePhysicsDriver` usa un cÃ¡lculo de velocidad simple:

```typescript
newVel.pan = deltaPan / dt  // dt = deltaTime en milisegundos
```

**En Live Mode:**
- `dt` â‰ˆ 16-33ms (30-60fps)
- `deltaPan` â‰ˆ 2-10 DMX units (movimiento suave)
- `velocity` â‰ˆ 0.1-0.6 DMX/ms â†’ OK

**En Chronos Mode (Phantom Mode):**
- `dt` = **HARDCODED a 16ms** (lÃ­neas 628 y 882 de HAL)
- Pero el playhead puede:
  - **Pausar** â†’ target no cambia durante 500ms+ â†’ siguiente frame tiene `deltaPan = 180` (salto square) pero `dt = 16ms`
  - **Scrubbing** â†’ saltos de 100-500ms en el playhead
  - **Saltos** â†’ cambio de vibe en timeline

**Con patterns square (Techno):**
- Square mueve de -90Â° a +90Â° (180 DMX units) **instantÃ¡neamente**
- Si hay lag/pausa, el siguiente frame ve:
  ```
  deltaPan = 180 (target cambiÃ³ mientras estaba pausado)
  dt = 16ms (mentira hardcoded)
  velocity = 180 / 16 = 11.25 DMX/ms
  ```
- Con REV_LIMIT_PAN = 120 (Techno), esto pasa.
- PERO si el lag es mayor o hay mÃ¡s saltos acumulados:
  ```
  deltaPan = 255 (lÃ­mite fÃ­sico)
  dt = 16ms
  velocity = 15.9 DMX/ms â†’ Puede pasar REV_LIMIT con acumulaciones
  ```
- **Resultado:** `velocity â†’ Infinity` â†’ NaN Guard activa â†’ fixture congelado en home position.

---

## ðŸ”§ THE FIX

### 1. Triple-Mode DeltaTime Strategy (FixturePhysicsDriver)

**Archivo:** `FixturePhysicsDriver.ts` lÃ­neas 320-370

```typescript
// WAVE 2040.2: PHANTOM MODE PROTECTION
// WAVE 2040.2b: ANTI-FREEZE TELEPORT MODE

if (deltaTime > 200) {
  // ðŸš€ TELEPORT MODE: Timeline jump (e.g., 0s â†’ 2:00)
  // Skip physics entirely, jump instantly
  // Prevents 7,500-iteration freeze on large timeline jumps
  smoothedDMX = targetDMX
  this.currentPositions.set(fixtureId, targetDMX)
  this.velocities.set(fixtureId, { pan: 0, tilt: 0 })
  
  console.log(`[ðŸš€ TELEPORT] ${fixtureId} | dt=${deltaTime}ms â†’ instant jump`)
  
} else if (deltaTime > 50) {
  // ðŸŽ¬ PHANTOM MODE: Iterative chunking for medium deltas
  const CHUNK_SIZE = 16
  const iterations = Math.ceil(deltaTime / CHUNK_SIZE)
  
  let currentTarget = targetDMX
  for (let i = 0; i < iterations; i++) {
    smoothedDMX = this.applyPhysicsEasing(fixtureId, currentTarget, CHUNK_SIZE)
    currentTarget = smoothedDMX
  }
  
} else {
  // âœ… LIVE MODE: Normal deltaTime - single pass
  smoothedDMX = this.applyPhysicsEasing(fixtureId, targetDMX, deltaTime)
}
```

**Estrategia Triple:**

| Mode | DeltaTime | AcciÃ³n | Ejemplo |
|------|-----------|--------|---------|
| **LIVE** | < 50ms | Single-pass physics | 30fps playback (33ms) |
| **PHANTOM** | 50-200ms | Iterative chunking (16ms) | Lag/pause (100ms) â†’ 6 chunks |
| **TELEPORT** | > 200ms | Skip physics, instant jump | Timeline jump 0sâ†’2:00 (120,000ms) |

**Â¿Por quÃ© 200ms como lÃ­mite?**
- **50ms**: 30fps = 33ms/frame. Si > 50ms, hubo lag/pausa â†’ chunking.
- **200ms**: MÃ¡s de 6 frames perdidos = salto intencional del usuario, no lag.
- **Ejemplo crÃ­tico**: 120,000ms / 16ms = **7,500 iteraciones** â†’ congelarÃ­a React UI por segundos.

**TELEPORT MODE evita:**
```
deltaTime = 120,000ms (2 minutos)
â†’ sin TELEPORT: 7,500 iteraciones en bucle
â†’ con TELEPORT: 1 asignaciÃ³n directa + reset velocity
â†’ tiempo de ejecuciÃ³n: < 0.1ms vs ~200ms
```

### 2. Reinforced NaN Guard (Velocity Explosion Protection)

**Archivo:** `FixturePhysicsDriver.ts` lÃ­neas 661-680

```typescript
// WAVE 2040.2: REINFORCED NaN GUARD - Velocity Explosion Protection
const safeVelPan = dt > 0.1 ? deltaPan / dt : 0
const safeVelTilt = dt > 0.1 ? deltaTilt / dt : 0

newVel.pan = Number.isFinite(safeVelPan) ? safeVelPan : 0
newVel.tilt = Number.isFinite(safeVelTilt) ? safeVelTilt : 0

// Debugging: alertar si se detectÃ³ explosiÃ³n
if (!Number.isFinite(safeVelPan) || !Number.isFinite(safeVelTilt)) {
  console.warn(`[PhysicsDriver] ðŸ”§ WAVE 2040.2: Velocity explosion detected! dt=${dt.toFixed(2)}ms, deltaPan=${deltaPan.toFixed(1)}, deltaTilt=${deltaTilt.toFixed(1)} â†’ velocity reset to 0`)
}
```

**ProtecciÃ³n doble:**
1. **Division by zero**: Si `dt < 0.1ms` â†’ velocity = 0 (evita divisiÃ³n por casi-cero)
2. **Infinity check**: Si el resultado NO es finito â†’ velocity = 0 (resetear, no congelar)

**Antes:**
```typescript
newVel.pan = deltaPan / dt  // Si dt=0 â†’ Infinity â†’ NaN Guard â†’ fixture congelado
```

**DespuÃ©s:**
```typescript
newVel.pan = (dt > 0.1 && Number.isFinite(deltaPan/dt)) ? deltaPan/dt : 0
// Si hay problema â†’ velocity = 0, fixture NO congelado (continÃºa moviÃ©ndose)
```

### 3. Cinema Simulator NaN Guard

**Archivo:** `StageSimulatorCinema.tsx` lÃ­neas ~580

```typescript
// WAVE 2040.2: REINFORCED NaN GUARD FOR CINEMA RENDERER
// Si physicalPan/physicalTilt llegan corruptos (NaN/Infinity),
// el canvas NO debe pintarse con valores invÃ¡lidos.
// Fallback: 0.5 (center position)
physicalPan: Number.isFinite(renderData.physicalPan) ? renderData.physicalPan : 0.5,
physicalTilt: Number.isFinite(renderData.physicalTilt) ? renderData.physicalTilt : 0.5,
zoom: Number.isFinite(renderData.zoom) ? renderData.zoom : 127,
focus: Number.isFinite(renderData.focus) ? renderData.focus : 127,
panVelocity: Number.isFinite(renderData.panVelocity) ? renderData.panVelocity : 0,
tiltVelocity: Number.isFinite(renderData.tiltVelocity) ? renderData.tiltVelocity : 0,
```

Asegura que el renderer nunca reciba NaN/Infinity. Si llega corrupto, usa valores safe en lugar de corromper el canvas.

---

## ðŸ§ª TESTING

### Manual Test Plan (Para Radwulf)

**Setup:**
1. Abrir Chronos
2. Cargar Vibe Techno (con pattern square)
3. Colocar algunos clips en el timeline

**Test 1: ReproducciÃ³n Normal**
- â–¶ Play timeline
- âœ… Fixtures deben moverse correctamente (saltos secos square visibles)
- âœ… NO congelarse

**Test 2: Scrubbing**
- Arrastrar playhead rÃ¡pidamente adelante/atrÃ¡s
- âœ… Fixtures deben seguir el target sin congelarse
- âœ… Console log debe mostrar: `[ðŸŽ¬ PHANTOM] mover_left_0 | dt=XXXms â†’ Y chunks` (si dt > 50ms)

**Test 3: Pause/Resume**
- â–¶ Play â†’ Pause (5s) â†’ â–¶ Play
- âœ… Fixtures deben retomar movimiento inmediatamente
- âœ… NO quedarse pegados

**Test 4: ComparaciÃ³n Live vs Chronos**
- Test Vibe Techno en **Live Mode** (sin Chronos)
- Test Vibe Techno en **Chronos Mode** (timeline)
- âœ… Comportamiento debe ser visualmente IDÃ‰NTICO

**Test 5: Timeline Jump (TELEPORT MODE)**
- Timeline en 0:00
- Click en 2:00 (120 segundos)
- âœ… Fixtures deben saltar instantÃ¡neamente a la posiciÃ³n del segundo 120
- âœ… Console log debe mostrar: `[ðŸš€ TELEPORT] mover_left_0 | dt=120000ms â†’ instant jump`
- âœ… UI NO debe congelarse (< 1ms de procesamiento)

### Automated Tests

```
488/488 tests passed
0 new failures introduced by this fix
```

---

## ðŸ“Š EXPECTED BEHAVIOR

### Antes del Fix

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Timeline: Pause (500ms)                â”‚
â”‚ Next Frame:                             â”‚
â”‚   deltaPan = 180 (square jump)         â”‚
â”‚   dt = 16ms (hardcoded lie)            â”‚
â”‚   velocity = 180/16 = 11.25 DMX/ms     â”‚
â”‚   â†’ AcumulaciÃ³n â†’ Infinity             â”‚
â”‚   â†’ NaN Guard â†’ fixture congelado      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### DespuÃ©s del Fix

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Timeline: Pause (500ms)                â”‚
â”‚ Next Frame:                             â”‚
â”‚   deltaTime = 500ms detected           â”‚
â”‚   â†’ Iterative chunking: 31 iterations  â”‚
â”‚   Each iteration: dt=16ms, deltaPan=~6 â”‚
â”‚   velocity = 6/16 = 0.375 DMX/ms       â”‚
â”‚   â†’ Estable, sin explosiÃ³n             â”‚
â”‚   â†’ Fixture se mueve normalmente       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ðŸ”® FUTURE WORK (OPCIONAL)

**Propagar `deltaTime` real desde TitanOrchestrator:**

Actualmente, HAL siempre pasa `deltaTime = 16ms` (hardcoded). El fix actual **funciona** dividiendo en chunks, pero lo ideal serÃ­a:

1. Calcular `deltaTime` real en TitanOrchestrator (basado en `performance.now()` o timestamp del frame)
2. Pasar ese `deltaTime` a `HAL.render()` y `HAL.renderFromTarget()`
3. HAL lo propaga a `translateDMX()`

**Por quÃ© NO es urgente:**
- El fix de chunking iterativo **resuelve el bug completamente**
- Cambiar la firma de HAL.render() requiere tocar mÃºltiples puntos de integraciÃ³n
- El overhead de las iteraciones es mÃ­nimo (< 0.5ms para 500ms de lag)

**Beneficio potencial:**
- CÃ³digo mÃ¡s limpio (no hardcoded)
- Soporte para velocidades de playback variables (2x, 0.5x)
