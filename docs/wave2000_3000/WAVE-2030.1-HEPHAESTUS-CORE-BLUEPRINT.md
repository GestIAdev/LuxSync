# âš’ï¸ WAVE 2030.1: HEPHAESTUS CORE
## Blueprint: Multi-Parameter Keyframe System & Curve Evaluator Engine

**Architect**: PunkOpus | **Fecha**: 11 Feb 2026 | **Codename**: HEPHAESTUS  
**Status**: ğŸ“ BLUEPRINT | **Target**: FX Creator Foundation

---

## 0. EL NOMBRE

**Hephaestus** - El dios griego de la forja. El que construye las armas de los dioses.

Los efectos de LuxSync son las armas. El arsenal actual tiene 40+ efectos hardcodeados en TypeScript.
Hephaestus es la forja que permite al usuario **crear sus propias armas** sin tocar cÃ³digo.

La analogÃ­a es exacta: Hephaestus toma metal bruto (parÃ¡metros) y los moldea en curvas (keyframes)
para producir armas divinas (efectos custom).

---

## 1. DIAGNÃ“STICO DEL SISTEMA ACTUAL

### 1.1 El FXClip Primitivo

```typescript
// TimelineClip.ts - ESTADO ACTUAL
interface FXKeyframe {
  offsetMs: number    // Tiempo relativo al inicio del clip
  value: number       // Un solo valor (0-1) â† EL PROBLEMA
  easing: 'linear' | 'ease-in' | 'ease-out' | 'ease-in-out' | 'step'
}

interface FXClip {
  fxType: FXType       // 8 tipos hardcoded
  keyframes: FXKeyframe[]  // Solo 1 curva: intensity
  params: Record<string, number | string | boolean>  // Flat, no temporal
}
```

**Problema fundamental**: Un FXClip tiene UNA curva de intensity y `params` estÃ¡ticos.
No puede decir "speed sube de 0.2 a 1.0 durante el efecto" ni "color cambia de cyan a magenta".

### 1.2 CÃ³mo BaseEffect Consume Keyframes (Spoiler: No Lo Hace)

```typescript
// BaseEffect.ts - ACTUAL
// getProgress() â†’ 0-1 basado en elapsedMs
// _forceProgress() â†’ Chronos override

// Pero NO hay mecanismo para:
// 1. Recibir curvas multi-parÃ¡metro
// 2. Evaluar valores interpolados por parÃ¡metro
// 3. Inyectar valores de curva en update()
```

Los efectos hardcodeados definen sus propios parÃ¡metros internos.
`AcidSweep` tiene `bladeWidth`, `sweepDurationMs`, `harshnessThreshold`...
todos fijos en `DEFAULT_CONFIG`. El usuario no puede tocarlos.

### 1.3 El Gap del ChronosInjector

```typescript
// ChronosInjector.ts - ACTUAL
// tick() solo emite: 'fx-trigger', 'fx-stop', 'vibe-change'
// NO emite valores de keyframe interpolados
// NO envÃ­a params temporales al EffectManager
```

ChronosInjector sabe QUÃ‰ clip estÃ¡ activo pero no CÃ“MO modularlo.

---

## 2. ARQUITECTURA HEPHAESTUS: DATA STRUCTURES

### 2.1 El Keyframe AtÃ³mico

```typescript
/**
 * âš’ï¸ WAVE 2030.1: HEPHAESTUS KEYFRAME
 * 
 * Un keyframe es un punto de control en el tiempo.
 * Dos keyframes consecutivos definen un segmento interpolable.
 * 
 * La innovaciÃ³n: cubic-bezier handles para curvas orgÃ¡nicas,
 * no solo las 4 easings de CSS.
 */
interface HephKeyframe {
  /** Tiempo en ms desde inicio del clip */
  timeMs: number
  
  /** 
   * Valor en este punto.
   * - number: Para intensity, speed, zoom, pan, tilt (0-1 normalizado)
   * - HSL: Para color { h: 0-360, s: 0-100, l: 0-100 }
   */
  value: number | HSL
  
  /**
   * InterpolaciÃ³n HACIA el siguiente keyframe.
   * 
   * 'hold'   â†’ Valor constante hasta el siguiente keyframe (step function)
   * 'linear' â†’ LÃ­nea recta
   * 'bezier' â†’ Cubic bezier (curva orgÃ¡nica) - requiere handles
   */
  interpolation: 'hold' | 'linear' | 'bezier'
  
  /**
   * Handles de control para cubic-bezier.
   * Solo relevante cuando interpolation === 'bezier'.
   * 
   * Formato: [cx1, cy1, cx2, cy2]
   * Donde cx/cy son posiciones relativas (0-1) del punto de control.
   * 
   * Presets comunes:
   * - ease-in:     [0.42, 0,    1,    1   ]
   * - ease-out:    [0,    0,    0.58, 1   ]
   * - ease-in-out: [0.42, 0,    0.58, 1   ]
   * - overshoot:   [0.68, -0.6, 0.32, 1.6 ]
   * - bounce:      [0.34, 1.56, 0.64, 1   ]
   * - snap:        [0.9,  0,    0.1,  1   ]
   */
  bezierHandles?: [number, number, number, number]
}

interface HSL {
  h: number  // 0-360
  s: number  // 0-100
  l: number  // 0-100
}
```

**Â¿Por quÃ© cubic-bezier en lugar de easings nombradas?**

Las easings nombradas (`ease-in`, `ease-out`) son un subconjunto de cubic-bezier.
Con 4 floats, el usuario tiene control total sobre la curva.
En la UI, se ofrecen presets (ease-in, snap, overshoot...) pero
el usuario puede arrastrar los handles para crear curvas Ãºnicas.

Esto es exactamente lo que hace After Effects, Blender, y Ableton.
Es el estÃ¡ndar de la industria creativa. No inventamos, adoptamos lo mejor.

### 2.2 La Curva de AutomatizaciÃ³n

```typescript
/**
 * âš’ï¸ WAVE 2030.1: HEPHAESTUS AUTOMATION CURVE
 * 
 * Una curva es una secuencia ordenada de keyframes para UN parÃ¡metro.
 * Es la unidad atÃ³mica de automatizaciÃ³n.
 * 
 * INVARIANTES:
 * - keyframes SIEMPRE estÃ¡n ordenados por timeMs (ascendente)
 * - MÃ­nimo 1 keyframe (valor constante)
 * - El primer keyframe define el valor inicial
 * - El Ãºltimo keyframe define el valor final
 * - Consultas fuera de rango clampean al primer/Ãºltimo valor
 */
interface HephCurve {
  /** ID del parÃ¡metro que esta curva controla */
  paramId: HephParamId
  
  /** Tipo de valor para validaciÃ³n */
  valueType: 'number' | 'color'
  
  /** Rango vÃ¡lido para valores numÃ©ricos [min, max] */
  range: [number, number]
  
  /** Valor por defecto cuando no hay keyframes activos */
  defaultValue: number | HSL
  
  /** Keyframes ordenados por tiempo */
  keyframes: HephKeyframe[]
}

/**
 * IDs de parÃ¡metros que Hephaestus puede controlar.
 * Esto se mapea 1:1 a lo que BaseEffect y EffectFrameOutput pueden producir.
 */
type HephParamId = 
  | 'intensity'    // â†’ dimmerOverride (0-1)
  | 'color'        // â†’ colorOverride (HSL)
  | 'white'        // â†’ whiteOverride (0-1)
  | 'amber'        // â†’ amberOverride (0-1)
  | 'speed'        // â†’ param interno del efecto (0-1 normalizado)
  | 'pan'          // â†’ movement.pan (-1 a 1)
  | 'tilt'         // â†’ movement.tilt (-1 a 1)
  | 'zoom'         // â†’ param interno del efecto (0-1)
  | 'strobe'       // â†’ strobeRate mapping (0=off, 1=maxHz)
  | 'globalComp'   // â†’ globalComposition (0-1)
  | 'width'        // â†’ param interno (beam width, chase width, etc.)
  | 'direction'    // â†’ param interno (sweep direction) (0=Lâ†’R, 1=Râ†’L)
```

### 2.3 El AutomationClip: La Pieza Completa

```typescript
/**
 * âš’ï¸ WAVE 2030.1: HEPHAESTUS AUTOMATION CLIP
 * 
 * Un AutomationClip es un FXClip evolucionado.
 * Contiene MÃšLTIPLES curvas (una por parÃ¡metro automatizado).
 * 
 * Es lo que se guarda en el archivo .lfx y lo que
 * Chronos coloca en el timeline.
 */
interface HephAutomationClip {
  /** Metadata */
  id: string
  name: string
  author: string
  category: EffectCategory
  tags: string[]
  
  /** Compatibilidad de vibes (vacÃ­o = todas) */
  vibeCompat: string[]
  
  /** Zonas objetivo */
  zones: EffectZone[]
  
  /** Mix bus */
  mixBus: 'htp' | 'global'
  
  /** Prioridad (0-100) */
  priority: number
  
  /** DuraciÃ³n total del clip en ms */
  durationMs: number
  
  /**
   * El tipo de efecto BASE que este clip automatiza.
   * 
   * Si es un effectType existente (e.g., 'acid_sweep'),
   * Hephaestus modula sus parÃ¡metros internos.
   * 
   * Si es 'heph_custom', Hephaestus genera el output
   * directamente desde las curvas (bypass effect class).
   */
  effectType: string
  
  /**
   * LAS CURVAS - El corazÃ³n de Hephaestus
   * 
   * Map de paramId â†’ curva de automatizaciÃ³n
   * Solo se incluyen parÃ¡metros que tienen keyframes.
   * ParÃ¡metros no incluidos usan el valor por defecto del efecto.
   */
  curves: Map<HephParamId, HephCurve>
  
  /**
   * ParÃ¡metros estÃ¡ticos (no automatizados).
   * Para valores que no cambian durante el efecto.
   * Equivalente al `params` actual de FXClip.
   */
  staticParams: Record<string, number | string | boolean>
}
```

### 2.4 El Formato de Archivo `.lfx`

```typescript
/**
 * SerializaciÃ³n JSON del HephAutomationClip.
 * Map se serializa como Record.
 */
interface LFXFile {
  /** Schema version para migraciÃ³n futura */
  $schema: 'hephaestus/v1'
  
  /** VersiÃ³n del formato */
  version: '1.0.0'
  
  /** El clip */
  clip: {
    id: string
    name: string
    author: string
    category: string
    tags: string[]
    vibeCompat: string[]
    zones: string[]
    mixBus: 'htp' | 'global'
    priority: number
    durationMs: number
    effectType: string
    
    /** Curvas serializadas como object (no Map) */
    curves: Record<string, {
      paramId: string
      valueType: 'number' | 'color'
      range: [number, number]
      defaultValue: number | { h: number; s: number; l: number }
      keyframes: Array<{
        timeMs: number
        value: number | { h: number; s: number; l: number }
        interpolation: 'hold' | 'linear' | 'bezier'
        bezierHandles?: [number, number, number, number]
      }>
    }>
    
    staticParams: Record<string, number | string | boolean>
  }
  
  /** Checksum para integridad */
  checksum: string
}
```

---

## 3. CURVE EVALUATOR ENGINE

### 3.1 Requisitos de Performance

```
60 FPS Ã— 12 parÃ¡metros Ã— 50 efectos = 36,000 evaluaciones/segundo
Cada evaluaciÃ³n DEBE ser < 0.01ms (10 microsegundos)
Budget total: 0.36ms por frame â†’ ~1% del budget de 16.6ms
```

### 3.2 Estrategia: O(1) Amortizado con Cursor Cache

El truco para no hacer binary search (O(log n)) cada frame:

**ObservaciÃ³n clave**: En playback normal, el tiempo avanza monotÃ³nicamente.
El keyframe actual en frame N serÃ¡ el mismo o el siguiente en frame N+1.

```
Frame 100: t=2000ms â†’ segmento [kf2, kf3] (bÃºsqueda O(log n))
Frame 101: t=2033ms â†’ segmento [kf2, kf3] (MISMO â†’ O(1))
Frame 102: t=2066ms â†’ segmento [kf2, kf3] (MISMO â†’ O(1))
...
Frame 130: t=3000ms â†’ segmento [kf3, kf4] (AVANZAR cursor â†’ O(1))
```

Solo hacemos O(log n) en seek/scrub. En playback normal: **O(1)**.

### 3.3 La Clase CurveEvaluator

```typescript
/**
 * âš’ï¸ WAVE 2030.1: HEPHAESTUS CURVE EVALUATOR
 * 
 * Motor de evaluaciÃ³n de curvas de automatizaciÃ³n.
 * O(1) en playback normal, O(log n) en seek.
 * 
 * ARQUITECTURA:
 * - Un CurveEvaluator por HephAutomationClip
 * - Mantiene cursor cache por curva para O(1) amortizado
 * - EvaluaciÃ³n lazy (solo evalÃºa curvas que se consultan)
 * 
 * USO:
 * ```typescript
 * const evaluator = new CurveEvaluator(clip.curves)
 * 
 * // En cada frame:
 * const intensity = evaluator.getValue('intensity', currentTimeMs) // â†’ number
 * const color = evaluator.getColorValue('color', currentTimeMs)    // â†’ HSL
 * ```
 * 
 * @performance
 * - Playback normal: O(1) por evaluaciÃ³n (cursor cache)
 * - Seek/scrub: O(log n) para relocate cursor
 * - Memory: ~100 bytes por curva (cursor + segment cache)
 */
class CurveEvaluator {
  /** Curvas indexadas por paramId */
  private curves: Map<HephParamId, HephCurve>
  
  /**
   * Cursor cache: posiciÃ³n actual en cada curva.
   * Almacena el Ã­ndice del keyframe IZQUIERDO del segmento activo.
   * 
   * Ejemplo: si cursor['intensity'] = 2, el segmento activo es
   * [keyframes[2], keyframes[3]] y el tiempo estÃ¡ entre ambos.
   */
  private cursors: Map<HephParamId, number>
  
  /** Ãšltimo timeMs evaluado (para detectar seek) */
  private lastTimeMs: number = -1
  
  /** DuraciÃ³n total para clamp */
  private durationMs: number
  
  constructor(curves: Map<HephParamId, HephCurve>, durationMs: number) {
    this.curves = curves
    this.durationMs = durationMs
    this.cursors = new Map()
    
    // Inicializar cursores a 0
    for (const paramId of curves.keys()) {
      this.cursors.set(paramId, 0)
    }
  }
  
  /**
   * EvalÃºa el valor numÃ©rico de una curva en un instante de tiempo.
   * 
   * @param paramId ID del parÃ¡metro
   * @param timeMs Tiempo en ms desde inicio del clip
   * @returns Valor interpolado, o defaultValue si no hay curva
   */
  getValue(paramId: HephParamId, timeMs: number): number {
    const curve = this.curves.get(paramId)
    if (!curve || curve.keyframes.length === 0) {
      return typeof curve?.defaultValue === 'number' 
        ? curve.defaultValue 
        : 0
    }
    
    const kfs = curve.keyframes
    
    // Clamp time
    const t = Math.max(0, Math.min(timeMs, this.durationMs))
    
    // Edge cases
    if (kfs.length === 1) return kfs[0].value as number
    if (t <= kfs[0].timeMs) return kfs[0].value as number
    if (t >= kfs[kfs.length - 1].timeMs) return kfs[kfs.length - 1].value as number
    
    // Encontrar segmento activo
    const segIdx = this.findSegment(paramId, t, kfs)
    
    const kf0 = kfs[segIdx]
    const kf1 = kfs[segIdx + 1]
    
    // Progreso dentro del segmento (0-1)
    const segDuration = kf1.timeMs - kf0.timeMs
    if (segDuration <= 0) return kf0.value as number
    
    const segProgress = (t - kf0.timeMs) / segDuration
    
    // Interpolar segÃºn tipo
    return this.interpolateNumber(
      kf0.value as number,
      kf1.value as number,
      segProgress,
      kf0.interpolation,
      kf0.bezierHandles
    )
  }
  
  /**
   * EvalÃºa el valor de color de una curva en un instante de tiempo.
   * Interpola H, S, L independientemente (con shortest-path para Hue).
   */
  getColorValue(paramId: HephParamId, timeMs: number): HSL {
    const curve = this.curves.get(paramId)
    if (!curve || curve.keyframes.length === 0) {
      return (curve?.defaultValue as HSL) ?? { h: 0, s: 0, l: 50 }
    }
    
    const kfs = curve.keyframes
    const t = Math.max(0, Math.min(timeMs, this.durationMs))
    
    if (kfs.length === 1) return kfs[0].value as HSL
    if (t <= kfs[0].timeMs) return kfs[0].value as HSL
    if (t >= kfs[kfs.length - 1].timeMs) return kfs[kfs.length - 1].value as HSL
    
    const segIdx = this.findSegment(paramId, t, kfs)
    
    const kf0 = kfs[segIdx]
    const kf1 = kfs[segIdx + 1]
    
    const segDuration = kf1.timeMs - kf0.timeMs
    if (segDuration <= 0) return kf0.value as HSL
    
    const rawProgress = (t - kf0.timeMs) / segDuration
    
    // Aplicar curva bezier al progreso
    const easedProgress = this.applyInterpolation(
      rawProgress,
      kf0.interpolation,
      kf0.bezierHandles
    )
    
    // Interpolar HSL con shortest-path para Hue
    const c0 = kf0.value as HSL
    const c1 = kf1.value as HSL
    
    return {
      h: this.lerpHue(c0.h, c1.h, easedProgress),
      s: c0.s + (c1.s - c0.s) * easedProgress,
      l: c0.l + (c1.l - c0.l) * easedProgress,
    }
  }
  
  /**
   * Obtiene un snapshot de TODOS los parÃ¡metros en un instante.
   * Usado por el sistema de inyecciÃ³n para pasar al efecto.
   */
  getSnapshot(timeMs: number): HephParamSnapshot {
    const snapshot: HephParamSnapshot = {}
    
    for (const [paramId, curve] of this.curves) {
      if (curve.valueType === 'color') {
        snapshot[paramId] = this.getColorValue(paramId, timeMs)
      } else {
        snapshot[paramId] = this.getValue(paramId, timeMs)
      }
    }
    
    return snapshot
  }
  
  /**
   * Reset cursors (call on seek/scrub)
   */
  reset(): void {
    for (const paramId of this.curves.keys()) {
      this.cursors.set(paramId, 0)
    }
    this.lastTimeMs = -1
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // INTERNALS
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  /**
   * Encuentra el Ã­ndice del segmento activo.
   * O(1) en playback normal (cursor cache), O(log n) en seek.
   */
  private findSegment(
    paramId: HephParamId, 
    t: number, 
    kfs: HephKeyframe[]
  ): number {
    let cursor = this.cursors.get(paramId) ?? 0
    
    // Detectar direcciÃ³n
    const isForward = t >= this.lastTimeMs
    
    if (isForward) {
      // PLAYBACK NORMAL â†’ Avanzar cursor linealmente (O(1) amortizado)
      while (cursor < kfs.length - 2 && t >= kfs[cursor + 1].timeMs) {
        cursor++
      }
    } else {
      // SEEK HACIA ATRÃS â†’ Binary search (O(log n))
      cursor = this.binarySearchSegment(t, kfs)
    }
    
    // Clamp
    cursor = Math.max(0, Math.min(cursor, kfs.length - 2))
    
    // Actualizar cache
    this.cursors.set(paramId, cursor)
    this.lastTimeMs = t
    
    return cursor
  }
  
  /**
   * Binary search para encontrar segmento.
   * Solo se usa en seek/scrub (movimiento no-monotÃ³nico).
   */
  private binarySearchSegment(t: number, kfs: HephKeyframe[]): number {
    let lo = 0
    let hi = kfs.length - 2
    
    while (lo < hi) {
      const mid = (lo + hi + 1) >>> 1
      if (kfs[mid].timeMs <= t) {
        lo = mid
      } else {
        hi = mid - 1
      }
    }
    
    return lo
  }
  
  /**
   * Interpola entre dos valores numÃ©ricos con curva aplicada.
   */
  private interpolateNumber(
    v0: number,
    v1: number,
    progress: number,
    interpolation: 'hold' | 'linear' | 'bezier',
    handles?: [number, number, number, number]
  ): number {
    const t = this.applyInterpolation(progress, interpolation, handles)
    return v0 + (v1 - v0) * t
  }
  
  /**
   * Aplica la funciÃ³n de interpolaciÃ³n al progreso lineal.
   * Convierte progreso lineal (0-1) en progreso con easing (0-1).
   */
  private applyInterpolation(
    t: number,
    interpolation: 'hold' | 'linear' | 'bezier',
    handles?: [number, number, number, number]
  ): number {
    switch (interpolation) {
      case 'hold':
        return 0  // Step function: valor constante hasta el siguiente keyframe
      
      case 'linear':
        return t
      
      case 'bezier':
        if (!handles) return t
        return this.cubicBezierY(t, handles[0], handles[1], handles[2], handles[3])
      
      default:
        return t
    }
  }
  
  /**
   * EvaluaciÃ³n de Cubic Bezier.
   * 
   * La curva bezier mapea t (0-1) â†’ y (0-1).
   * Los puntos de control son:
   *   P0 = (0, 0)
   *   P1 = (cx1, cy1)
   *   P2 = (cx2, cy2)
   *   P3 = (1, 1)
   * 
   * El truco: necesitamos encontrar el parÃ¡metro paramÃ©trico 'u'
   * tal que bezierX(u) = t, y luego calcular bezierY(u).
   * 
   * Usamos iteraciÃ³n de Newton-Raphson (3 iteraciones = suficiente
   * precisiÃ³n para animaciÃ³n visual, O(1) constante).
   */
  private cubicBezierY(
    t: number,
    cx1: number,
    cy1: number,
    cx2: number,
    cy2: number
  ): number {
    // Edge cases
    if (t <= 0) return 0
    if (t >= 1) return 1
    
    // Newton-Raphson para encontrar u donde bezierX(u) = t
    // Bezier X(u) = 3(1-u)Â²uÂ·cx1 + 3(1-u)uÂ²Â·cx2 + uÂ³
    let u = t // Initial guess
    
    for (let i = 0; i < 4; i++) {
      const u2 = u * u
      const u3 = u2 * u
      const mu = 1 - u
      const mu2 = mu * mu
      
      // X(u)
      const x = 3 * mu2 * u * cx1 + 3 * mu * u2 * cx2 + u3
      
      // X'(u) - derivada
      const dx = 3 * mu2 * cx1 + 6 * mu * u * (cx2 - cx1) + 3 * u2 * (1 - cx2)
      
      if (Math.abs(dx) < 1e-7) break
      
      u -= (x - t) / dx
      u = Math.max(0, Math.min(1, u))
    }
    
    // Calcular Y(u) con el u encontrado
    const u2 = u * u
    const u3 = u2 * u
    const mu = 1 - u
    const mu2 = mu * mu
    
    return 3 * mu2 * u * cy1 + 3 * mu * u2 * cy2 + u3
  }
  
  /**
   * Interpola Hue por el camino mÃ¡s corto en el cÃ­rculo 0-360.
   * 
   * Ejemplo: de H=350 a H=10 â†’ va por 360/0, no por 180.
   */
  private lerpHue(h0: number, h1: number, t: number): number {
    let delta = h1 - h0
    
    // Shortest path
    if (delta > 180) delta -= 360
    if (delta < -180) delta += 360
    
    let result = h0 + delta * t
    if (result < 0) result += 360
    if (result >= 360) result -= 360
    
    return result
  }
}

/** Snapshot de todos los valores evaluados en un instante */
type HephParamSnapshot = Record<string, number | HSL>
```

---

## 4. INTEGRATION STRATEGY: INYECCIÃ“N SIN REESCRITURA

### 4.1 El Problema

Tenemos 40+ efectos hardcodeados. Cada uno tiene su propio `update()` con lÃ³gica interna.
**NO vamos a reescribir 40 clases**. Vamos a inyectar valores de curva por encima.

### 4.2 La SoluciÃ³n: HephParameterOverlay

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ FLUJO DE DATOS ACTUAL (sin Hephaestus)                      â”‚
â”‚                                                              â”‚
â”‚ Chronos tick() â†’ EffectManager.trigger() â†’ Effect.update()  â”‚
â”‚                                            â†’ Effect.getOutput()
â”‚                                                              â”‚
â”‚ Los parÃ¡metros internos del efecto SON el output.            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ FLUJO DE DATOS CON HEPHAESTUS                               â”‚
â”‚                                                              â”‚
â”‚ Chronos tick()                                               â”‚
â”‚   â”œâ”€ EffectManager.trigger(config + curveData)              â”‚
â”‚   â”‚     â””â”€ Effect.update()                                   â”‚
â”‚   â”‚         â””â”€ Effect.getOutput() â†’ rawOutput                â”‚
â”‚   â”‚                                                          â”‚
â”‚   â””â”€ CurveEvaluator.getSnapshot(timeMs) â†’ hephValues        â”‚
â”‚                                                              â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                     â”‚
â”‚         â”‚ HEPH OVERLAY â”‚ â† La capa nueva                    â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                                     â”‚
â”‚                â”‚                                             â”‚
â”‚         merge(rawOutput, hephValues) â†’ finalOutput           â”‚
â”‚                                                              â”‚
â”‚ Regla de merge:                                              â”‚
â”‚ - Si Hephaestus tiene curva para un param â†’ USA HEPHAESTUS  â”‚
â”‚ - Si no â†’ USA el valor original del efecto                   â”‚
â”‚                                                              â”‚
â”‚ El efecto base NO SABE que Hephaestus existe.               â”‚
â”‚ Zero modificaciones a los 40 efectos existentes.            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4.3 El Overlay Concreto

```typescript
/**
 * âš’ï¸ WAVE 2030.1: HEPHAESTUS PARAMETER OVERLAY
 * 
 * Capa que se coloca SOBRE el output de un efecto
 * y modula/reemplaza valores segÃºn curvas de automatizaciÃ³n.
 * 
 * PRINCIPIO: Transparencia total.
 * El efecto base no sabe que existe Hephaestus.
 * El EffectManager aplica el overlay DESPUÃ‰S del getOutput().
 */
class HephParameterOverlay {
  private evaluator: CurveEvaluator
  private clipDurationMs: number
  
  constructor(clip: HephAutomationClip) {
    this.evaluator = new CurveEvaluator(clip.curves, clip.durationMs)
    this.clipDurationMs = clip.durationMs
  }
  
  /**
   * Aplica las curvas de Hephaestus sobre el output raw de un efecto.
   * 
   * @param rawOutput Output original del efecto
   * @param timeMs Tiempo actual dentro del clip
   * @returns Output modificado con valores de curva
   */
  apply(rawOutput: EffectFrameOutput, timeMs: number): EffectFrameOutput {
    const snapshot = this.evaluator.getSnapshot(timeMs)
    
    // Clonar output para no mutar el original
    const output = { ...rawOutput }
    
    // INTENSITY â†’ dimmerOverride
    if ('intensity' in snapshot && typeof snapshot.intensity === 'number') {
      // Multiplicar: curva Hephaestus modula la intensity del efecto
      const baseIntensity = output.dimmerOverride ?? output.intensity ?? 1
      output.dimmerOverride = baseIntensity * (snapshot.intensity as number)
      output.intensity = output.dimmerOverride
    }
    
    // COLOR â†’ colorOverride
    if ('color' in snapshot && typeof snapshot.color === 'object') {
      output.colorOverride = snapshot.color as HSL
    }
    
    // WHITE â†’ whiteOverride
    if ('white' in snapshot && typeof snapshot.white === 'number') {
      output.whiteOverride = snapshot.white as number
    }
    
    // AMBER â†’ amberOverride
    if ('amber' in snapshot && typeof snapshot.amber === 'number') {
      output.amberOverride = snapshot.amber as number
    }
    
    // STROBE â†’ strobeRate (mapear 0-1 a Hz)
    if ('strobe' in snapshot && typeof snapshot.strobe === 'number') {
      // 0 = off, 1 = 18Hz (safe max de WAVE 1101)
      output.strobeRate = (snapshot.strobe as number) * 18
    }
    
    // PAN/TILT â†’ movement override
    if ('pan' in snapshot || 'tilt' in snapshot) {
      output.movement = {
        ...(output.movement ?? {}),
        isAbsolute: true,
      }
      if ('pan' in snapshot && typeof snapshot.pan === 'number') {
        // 0-1 de curva â†’ -1 a 1 de movement
        output.movement.pan = (snapshot.pan as number) * 2 - 1
      }
      if ('tilt' in snapshot && typeof snapshot.tilt === 'number') {
        output.movement.tilt = (snapshot.tilt as number) * 2 - 1
      }
    }
    
    // GLOBAL COMPOSITION
    if ('globalComp' in snapshot && typeof snapshot.globalComp === 'number') {
      output.globalComposition = snapshot.globalComp as number
    }
    
    return output
  }
  
  /** Reset evaluator (on seek) */
  reset(): void {
    this.evaluator.reset()
  }
}
```

### 4.4 IntegraciÃ³n en EffectManager

```typescript
// En EffectManager.ts - LOS ÃšNICOS CAMBIOS

class EffectManager {
  // NUEVO: Map de overlays activos
  private overlays: Map<string, HephParameterOverlay> = new Map()
  
  /**
   * TRIGGER EXTENDIDO
   * Si el config incluye curvas Hephaestus, crear overlay
   */
  trigger(config: EffectTriggerConfig): string | null {
    // ... (lÃ³gica actual sin cambios) ...
    
    // NUEVO: Si hay curvas Hephaestus, crear overlay
    if (config.hephCurves) {
      this.overlays.set(effect.id, new HephParameterOverlay(config.hephCurves))
    }
    
    return effect.id
  }
  
  /**
   * GET OUTPUT - MODIFICACIÃ“N MÃNIMA
   * DespuÃ©s de obtener el output raw, aplicar overlay si existe
   */
  getOutput(musicalContext: MusicalContext): EffectFrameOutput[] {
    const outputs: EffectFrameOutput[] = []
    
    for (const [id, effect] of this.activeEffects) {
      effect.update(deltaMs)
      const rawOutput = effect.getOutput()
      
      if (rawOutput) {
        // NUEVO: Aplicar overlay Hephaestus si existe
        const overlay = this.overlays.get(id)
        if (overlay) {
          const timeMs = effect.getProgress() * effect._durationMs
          outputs.push(overlay.apply(rawOutput, timeMs))
        } else {
          outputs.push(rawOutput)
        }
      }
      
      // Cleanup finished
      if (effect.isFinished()) {
        this.activeEffects.delete(id)
        this.overlays.delete(id)  // NUEVO: limpiar overlay
      }
    }
    
    return outputs
  }
}
```

**Impacto total en EffectManager**: ~15 lÃ­neas de cÃ³digo nuevo.
**Impacto en los 40 efectos existentes**: ZERO lÃ­neas. No se tocan.

### 4.5 IntegraciÃ³n en ChronosInjector

```typescript
// ChronosInjector.ts - EXTENSIÃ“N

interface StageCommand {
  // ... (campos existentes) ...
  
  /** NUEVO: Curvas Hephaestus para automatizaciÃ³n multi-parÃ¡metro */
  hephCurves?: HephAutomationClip
}

// En tick():
for (const fx of activeFx) {
  if (!this.prevState.activeFxMap.has(fx.id)) {
    this.emit({
      type: 'fx-trigger',
      effectId: fx.fxType,
      displayName: fx.label,
      durationMs: fx.endMs - fx.startMs,
      
      // NUEVO: Si el FXClip tiene curvas Hephaestus, incluirlas
      hephCurves: fx.hephClip ?? undefined,
    })
  }
}
```

### 4.6 Modo Custom: `heph_custom`

Para efectos creados enteramente en el FX Creator (sin clase base):

```typescript
/**
 * âš’ï¸ HEPH CUSTOM EFFECT
 * 
 * Efecto que NO tiene clase TypeScript.
 * Su output se genera 100% desde las curvas de Hephaestus.
 * 
 * Esto permite crear efectos sin escribir cÃ³digo.
 */
class HephCustomEffect extends BaseEffect {
  readonly effectType = 'heph_custom'
  readonly name: string
  readonly category: EffectCategory
  readonly priority: number
  readonly mixBus: 'htp' | 'global'
  
  private clip: HephAutomationClip
  private evaluator: CurveEvaluator
  
  constructor(clip: HephAutomationClip) {
    super('heph_custom')
    this.clip = clip
    this.name = clip.name
    this.category = clip.category
    this.priority = clip.priority
    this.mixBus = clip.mixBus
    this.zones = clip.zones
    this.evaluator = new CurveEvaluator(clip.curves, clip.durationMs)
    this.setDuration(clip.durationMs)
  }
  
  update(deltaMs: number): void {
    if (this.phase === 'finished') return
    this.elapsedMs += deltaMs
    
    if (this.elapsedMs >= this.clip.durationMs) {
      this.phase = 'finished'
    }
  }
  
  getOutput(): EffectFrameOutput | null {
    if (this.phase === 'finished') return null
    
    const progress = this.getProgress()
    const timeMs = progress * this.clip.durationMs
    const snapshot = this.evaluator.getSnapshot(timeMs)
    
    // Construir output directamente desde curvas
    const output: EffectFrameOutput = {
      effectId: this.id,
      category: this.category,
      phase: this.phase,
      progress,
      zones: this.zones,
      intensity: (snapshot.intensity as number) ?? 1,
    }
    
    if ('intensity' in snapshot) {
      output.dimmerOverride = snapshot.intensity as number
    }
    if ('color' in snapshot) {
      output.colorOverride = snapshot.color as HSL
    }
    if ('white' in snapshot) {
      output.whiteOverride = snapshot.white as number
    }
    if ('strobe' in snapshot) {
      output.strobeRate = (snapshot.strobe as number) * 18
    }
    if ('pan' in snapshot || 'tilt' in snapshot) {
      output.movement = {
        isAbsolute: true,
        pan: 'pan' in snapshot ? (snapshot.pan as number) * 2 - 1 : undefined,
        tilt: 'tilt' in snapshot ? (snapshot.tilt as number) * 2 - 1 : undefined,
      }
    }
    if ('globalComp' in snapshot) {
      output.globalComposition = snapshot.globalComp as number
    }
    
    return output
  }
}
```

---

## 5. REACT COMPONENT SPECS: CurveEditor

### 5.1 DecisiÃ³n de Stack: SVG Nativo

**Â¿Por quÃ© NO usar visx/d3/canvas?**

| OpciÃ³n | Pro | Contra |
|--------|-----|--------|
| Canvas 2D | Fast rendering | No DOM events, manual hit-testing |
| visx | Pretty charts | 50KB+ bundle, graph-oriented not animation-oriented |
| SVG nativo | DOM events gratis, CSS styling, lightweight | Slow con 1000+ elementos |

**DecisiÃ³n**: SVG nativo. Un CurveEditor tendrÃ¡ mÃ¡ximo ~50 keyframes.
SVG maneja 50 elementos sin pestaÃ±ear. Y los `mousedown`, `mousemove`
vienen gratis sin hit-testing manual.

### 5.2 Props del CurveEditor

```typescript
interface CurveEditorProps {
  /** La curva a editar */
  curve: HephCurve
  
  /** DuraciÃ³n total del clip (para eje X) */
  durationMs: number
  
  /** Dimensiones del editor */
  width: number
  height: number
  
  /** Padding interno */
  padding?: { top: number; right: number; bottom: number; left: number }
  
  /** Grid de beats (para snap) */
  beatGrid?: number[]
  
  /** Snap to grid habilitado */
  snapEnabled?: boolean
  
  /** ResoluciÃ³n del snap (ms) */
  snapResolutionMs?: number
  
  /** Color del parÃ¡metro (para la lÃ­nea de la curva) */
  curveColor?: string
  
  /** Â¿Mostrar handles de bezier? */
  showBezierHandles?: boolean
  
  /** Â¿Es este parÃ¡metro de tipo color? */
  isColorParam?: boolean
  
  /** Read-only mode */
  readOnly?: boolean
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // CALLBACKS
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  /** Keyframe aÃ±adido (double-click en curva) */
  onKeyframeAdd: (timeMs: number, value: number) => void
  
  /** Keyframe movido (drag) */
  onKeyframeMove: (index: number, timeMs: number, value: number) => void
  
  /** Keyframe eliminado (right-click o delete key) */
  onKeyframeDelete: (index: number) => void
  
  /** Tipo de interpolaciÃ³n cambiado */
  onInterpolationChange: (
    index: number, 
    interpolation: 'hold' | 'linear' | 'bezier'
  ) => void
  
  /** Bezier handles movidos */
  onBezierHandleMove: (
    index: number, 
    handles: [number, number, number, number]
  ) => void
  
  /** Playhead position (para preview line) */
  playheadMs?: number
}
```

### 5.3 Comportamiento del CurveEditor

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CurveEditor SVG Layout                                           â”‚
â”‚                                                                   â”‚
â”‚  1.0 â”€â”¬â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€â”‚
â”‚       â”‚          â—â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â—                            â”‚
â”‚       â”‚       â•±â•±                     â•²â•²                          â”‚
â”‚  0.5 â”€â”¤    â•±â•±   Bezier curve          â•²â•²                        â”‚
â”‚       â”‚  â•±â•±                              â•²â•²                      â”‚
â”‚       â”‚â•±â•±                                  â•²â•²                    â”‚
â”‚  0.0 â”€â—â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€ â—â”€ â”€ â”€ â”€ â”€ â”€ â”€ â”€â”‚
â”‚       â”‚     â”‚     â”‚     â”‚     â”‚     â”‚     â”‚  â”‚                   â”‚
â”‚       0   Beat1 Beat2 Beat3 Beat4 Beat5 Beat6  2000ms           â”‚
â”‚                          â–²                                       â”‚
â”‚                     Playhead (red line)                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

INTERACCIONES:
 â— Keyframe node (drag to move, right-click to delete)
 â—‹ Bezier handle (drag to adjust curve shape)
 â• Curve path (double-click to add keyframe)
 â”‚ Beat grid line (snap target)
 â–² Playhead indicator (read-only)
```

**Interacciones:**

| AcciÃ³n | Resultado |
|--------|-----------|
| **Double-click** en curva | AÃ±ade keyframe en esa posiciÃ³n |
| **Drag** keyframe | Mueve en X (tiempo) e Y (valor) |
| **Drag** + Shift | Constrains a eje X o Y |
| **Right-click** keyframe | Context menu: Delete, Change interpolation |
| **Drag** bezier handle | Modifica forma de la curva |
| **Delete key** con keyframe seleccionado | Elimina keyframe |
| **Scroll wheel** | Zoom horizontal (timeline) |

### 5.4 SVG Rendering Strategy

```typescript
/**
 * Genera el path SVG para una curva de automatizaciÃ³n.
 * 
 * La curva se dibuja segmento a segmento:
 * - 'hold' â†’ lÃ­nea horizontal + vertical (step)
 * - 'linear' â†’ lÃ­nea recta (L)
 * - 'bezier' â†’ curva cÃºbica SVG (C)
 */
function buildCurvePath(
  curve: HephCurve,
  durationMs: number,
  width: number,
  height: number
): string {
  const kfs = curve.keyframes
  if (kfs.length === 0) return ''
  
  const toX = (timeMs: number) => (timeMs / durationMs) * width
  const toY = (value: number) => height - ((value as number) / (curve.range[1] - curve.range[0])) * height
  
  let path = `M ${toX(kfs[0].timeMs)} ${toY(kfs[0].value as number)}`
  
  for (let i = 0; i < kfs.length - 1; i++) {
    const kf0 = kfs[i]
    const kf1 = kfs[i + 1]
    const x0 = toX(kf0.timeMs)
    const y0 = toY(kf0.value as number)
    const x1 = toX(kf1.timeMs)
    const y1 = toY(kf1.value as number)
    
    switch (kf0.interpolation) {
      case 'hold':
        // Step function: horizontal â†’ vertical
        path += ` L ${x1} ${y0} L ${x1} ${y1}`
        break
      
      case 'linear':
        path += ` L ${x1} ${y1}`
        break
      
      case 'bezier': {
        const h = kf0.bezierHandles ?? [0.42, 0, 0.58, 1]
        // Mapear handles relativos (0-1) a coordenadas absolutas
        const cp1x = x0 + (x1 - x0) * h[0]
        const cp1y = y0 + (y1 - y0) * h[1]
        const cp2x = x0 + (x1 - x0) * h[2]
        const cp2y = y0 + (y1 - y0) * h[3]
        path += ` C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${x1} ${y1}`
        break
      }
    }
  }
  
  return path
}
```

---

## 6. INNOVACIÃ“N: COSAS QUE NADIE MÃS HACE

### 6.1 Audio-Bound Curves (Reactive Automation)

En consolas PRO, los keyframes son temporales (time-based).
En Hephaestus, un keyframe puede BINDEAR su valor a una fuente de audio:

```typescript
interface HephKeyframe {
  // ... campos existentes ...
  
  /**
   * AUDIO BINDING (opcional)
   * En lugar de un valor fijo, el keyframe lee de una fuente de audio.
   * 
   * Cuando estÃ¡ activo, 'value' se convierte en el DEFAULT
   * y el binding modula sobre Ã©l.
   */
  audioBinding?: {
    /** Fuente del audio */
    source: 'energy' | 'bass' | 'mid' | 'high' | 'beatPhase' | 'bpm'
    
    /** Rango de mapeo: [inputMin, inputMax] â†’ [outputMin, outputMax] */
    inputRange: [number, number]
    outputRange: [number, number]
    
    /** Suavizado (0 = instantÃ¡neo, 1 = muy suave) */
    smoothing: number
  }
}
```

**Ejemplo**: Un sweep cuya velocidad se bindea a `energy`:
- Energy baja (ballad) â†’ sweep lento (speed=0.3)
- Energy alta (drop) â†’ sweep rÃ¡pido (speed=1.0)
- Todo en tiempo real, sin keyframes manuales

### 6.2 Curve Templates (Presets de Curva)

```typescript
/**
 * Curvas prediseÃ±adas que el usuario puede arrastrar al editor.
 * Son la semilla de la creatividad.
 */
const CURVE_TEMPLATES = {
  // â”€â”€ Intensity â”€â”€
  'fade-in':       [{ t: 0, v: 0 }, { t: 1, v: 1, bezier: [0.42, 0, 1, 1] }],
  'fade-out':      [{ t: 0, v: 1 }, { t: 1, v: 0, bezier: [0, 0, 0.58, 1] }],
  'triangle':      [{ t: 0, v: 0 }, { t: 0.5, v: 1 }, { t: 1, v: 0 }],
  'plateau':       [{ t: 0, v: 0 }, { t: 0.15, v: 1 }, { t: 0.85, v: 1 }, { t: 1, v: 0 }],
  'pulse-4x':      [/* 4 triÃ¡ngulos */],
  'ramp-up':       [{ t: 0, v: 0.2 }, { t: 1, v: 1 }],
  'ramp-down':     [{ t: 0, v: 1 }, { t: 1, v: 0.2 }],
  
  // â”€â”€ Movement â”€â”€
  'sweep-lr':      [{ t: 0, v: 0 }, { t: 1, v: 1 }],
  'sweep-rl':      [{ t: 0, v: 1 }, { t: 1, v: 0 }],
  'sweep-pingpong':[{ t: 0, v: 0 }, { t: 0.5, v: 1 }, { t: 1, v: 0 }],
  'figure-8':      [/* curva paramÃ©trica */],
  'circle':        [/* curva sinusoidal offset */],
  
  // â”€â”€ Color â”€â”€
  'rainbow':       [/* H: 0â†’360 lineal */],
  'warm-cold':     [/* H: 30â†’220 */],
  'pulse-white':   [/* L: 50â†’100â†’50 */],
  
  // â”€â”€ Speed â”€â”€
  'accelerate':    [{ t: 0, v: 0.2, bezier: [0.42, 0, 1, 1] }, { t: 1, v: 1 }],
  'decelerate':    [{ t: 0, v: 1 }, { t: 1, v: 0.2, bezier: [0, 0, 0.58, 1] }],
  'rubberband':    [{ t: 0, v: 0.5 }, { t: 0.3, v: 1 }, { t: 0.6, v: 0.3 }, { t: 1, v: 0.7 }],
}
```

### 6.3 Relative Curves (Multiplicador sobre el efecto base)

Hephaestus soporta DOS modos de operaciÃ³n por curva:

```typescript
interface HephCurve {
  // ... campos existentes ...
  
  /**
   * Modo de aplicaciÃ³n de la curva.
   * 
   * 'absolute' â†’ El valor de la curva REEMPLAZA el del efecto
   *   Ejemplo: intensity curva = 0.5 â†’ dimmer = 0.5
   * 
   * 'relative' â†’ El valor de la curva MULTIPLICA el del efecto
   *   Ejemplo: intensity curva = 0.5, efecto genera 0.8 â†’ dimmer = 0.4
   * 
   * 'additive' â†’ El valor de la curva SE SUMA al del efecto
   *   Ejemplo: pan curva = 0.1, efecto genera 0.3 â†’ pan = 0.4
   */
  mode: 'absolute' | 'relative' | 'additive'
}
```

Esto permite:
- **Absolute**: "Quiero que el dimmer sea EXACTAMENTE esta curva"
- **Relative**: "Quiero que el dimmer SEA EL 70% de lo que el efecto genere" (envelope)
- **Additive**: "Quiero SUMAR un wobble de pan al movimiento del efecto"

### 6.4 Micro-Automation: Sub-Beat Precision

Los keyframes existentes usan `offsetMs` con resoluciÃ³n de 1ms.
Hephaestus aÃ±ade una opciÃ³n de BEAT-RELATIVE timing:

```typescript
interface HephKeyframe {
  /** Tiempo absoluto en ms */
  timeMs: number
  
  /**
   * Alternativa: tiempo en beats (mÃ¡s preciso para sync musical).
   * Si estÃ¡ definido, timeMs se ignora y se calcula desde BPM.
   * 
   * Formato: beats.subdivision
   * Ejemplo: 2.75 = beat 2, subdivisiÃ³n 3/4 (nota 16th)
   */
  timeBeat?: number
  
  // ...
}
```

Cuando el BPM cambia mid-song (acelerando de 128 a 140),
los keyframes beat-relative se adaptan automÃ¡ticamente.
Los keyframes ms-based mantienen timing fijo.

---

## 7. FILE TREE DEL MÃ“DULO

```
electron-app/src/
  core/
    hephaestus/                          â† NUEVO MÃ“DULO
      types.ts                           â† HephKeyframe, HephCurve, HephAutomationClip
      CurveEvaluator.ts                  â† Motor O(1) amortizado
      HephParameterOverlay.ts            â† Capa de inyecciÃ³n sobre BaseEffect
      HephCustomEffect.ts                â† Efecto generado desde curvas puras
      HephFileIO.ts                      â† Load/Save .lfx
      curveTemplates.ts                  â† Presets de curvas (fade-in, sweep, etc.)
      __tests__/
        CurveEvaluator.test.ts           â† Tests de interpolaciÃ³n y performance
        HephParameterOverlay.test.ts     â† Tests de inyecciÃ³n
        
  chronos/
    ui/
      fx-creator/                        â† NUEVO: UI del FX Creator
        FXCreatorPanel.tsx               â† Panel principal
        CurveEditor.tsx                  â† SVG keyframe editor
        CurveEditorKeyframe.tsx          â† Componente de keyframe draggable
        CurveEditorBezierHandle.tsx      â† Handles de bezier
        CurveEditorGrid.tsx              â† Grid de beats
        ParameterLane.tsx                â† Lane por parÃ¡metro (intensity, color, etc.)
        ParameterSelector.tsx            â† Dropdown para elegir quÃ© parÃ¡metro editar
        CurveTemplateDrawer.tsx          â† Drawer con presets de curvas
        PreviewStage.tsx                 â† Mini 3D/2D preview
        LibraryBrowser.tsx               â† Load/Save .lfx
```

---

## 8. PERFORMANCE BUDGET

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ OperaciÃ³n                  â”‚ Budget  â”‚ Real estimado      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ CurveEvaluator.getValue() â”‚ <10Î¼s   â”‚ ~2Î¼s (O(1) cache)  â”‚
â”‚ cubicBezierY() (Newton)   â”‚ <5Î¼s    â”‚ ~1Î¼s (4 iterations)â”‚
â”‚ getSnapshot() (12 params) â”‚ <120Î¼s  â”‚ ~25Î¼s              â”‚
â”‚ HephOverlay.apply()       â”‚ <50Î¼s   â”‚ ~10Î¼s (spread+set) â”‚
â”‚ Total per effect per frame â”‚ <200Î¼s  â”‚ ~40Î¼s              â”‚
â”‚                            â”‚         â”‚                    â”‚
â”‚ 50 efectos Ã— 60fps        â”‚ <600ms  â”‚ ~120ms (2ms/frame) â”‚
â”‚ Budget de frame (16.6ms)  â”‚         â”‚ ~12% del budget    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

12% del budget de frame para automatizaciÃ³n completa de 50 efectos simultÃ¡neos.
Sobra espacio. Podemos permitirnos el lujo de la precisiÃ³n.

---

## 9. DIAGRAMA DE FLUJO COMPLETO

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    FX CREATOR (UI)                               â”‚
â”‚                                                                   â”‚
â”‚  User diseÃ±a curvas â†’ HephAutomationClip â†’ Save .lfx            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 CHRONOS TIMELINE                                 â”‚
â”‚                                                                   â”‚
â”‚  Drag .lfx â†’ FXClip con hephClip adjunto â†’ timeline track       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚ tick() @ 30fps
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               CHRONOS INJECTOR                                   â”‚
â”‚                                                                   â”‚
â”‚  getActiveClips(t) â†’ emit('fx-trigger', { hephCurves })         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚ IPC
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              EFFECT MANAGER (Backend)                            â”‚
â”‚                                                                   â”‚
â”‚  trigger(config + hephCurves)                                    â”‚
â”‚    â”œâ”€ Crear Effect instance (AcidSweep, HephCustom, etc.)       â”‚
â”‚    â””â”€ Crear HephParameterOverlay(curves)                        â”‚
â”‚                                                                   â”‚
â”‚  getOutput() @ 30fps:                                            â”‚
â”‚    â”œâ”€ effect.update(deltaMs)                                     â”‚
â”‚    â”œâ”€ rawOutput = effect.getOutput()                             â”‚
â”‚    â”œâ”€ evaluator.getSnapshot(timeMs) â†’ hephValues                â”‚
â”‚    â””â”€ overlay.apply(rawOutput, hephValues) â†’ finalOutput        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              MASTER ARBITER â†’ HAL â†’ DMX                         â”‚
â”‚                                                                   â”‚
â”‚  finalOutput contiene:                                           â”‚
â”‚    - dimmerOverride (modulado por curva intensity)               â”‚
â”‚    - colorOverride (interpolado HSL con shortest-path hue)      â”‚
â”‚    - movement.pan/tilt (curvas de movimiento)                   â”‚
â”‚    - strobeRate (curva de strobe 0-18Hz)                        â”‚
â”‚    - globalComposition (curva de fade dictador)                  â”‚
â”‚                                                                   â”‚
â”‚  HAL no sabe ni le importa si viene de efecto o de Hephaestus  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 10. BACKWARD COMPATIBILITY MATRIX

| Componente | Cambio Requerido | Riesgo |
|------------|-----------------|--------|
| BaseEffect.ts | ZERO cambios | ğŸŸ¢ Ninguno |
| 40+ efectos existentes | ZERO cambios | ğŸŸ¢ Ninguno |
| EffectManager.ts | +15 lÃ­neas (overlay check) | ğŸŸ¡ Bajo |
| EffectTriggerConfig | +1 campo opcional | ğŸŸ¢ Ninguno (optional) |
| ChronosInjector.ts | +1 campo en StageCommand | ğŸŸ¢ Ninguno (optional) |
| FXClip interface | +1 campo opcional (hephClip) | ğŸŸ¢ Ninguno (optional) |
| HAL pipeline | ZERO cambios | ğŸŸ¢ Ninguno |
| MasterArbiter | ZERO cambios | ğŸŸ¢ Ninguno |
| Timeline UI | Necesita FX Creator panel | ğŸŸ¡ New code |

**Total: 2 archivos modificados, 0 archivos rotos.**

---

## 11. TESTS CRÃTICOS

```typescript
describe('CurveEvaluator', () => {
  it('returns default for empty curve', () => {
    const curve = { keyframes: [], defaultValue: 0.5 }
    expect(evaluator.getValue('intensity', 1000)).toBe(0.5)
  })
  
  it('clamps before first keyframe', () => {
    const curve = { keyframes: [{ timeMs: 500, value: 0.8 }] }
    expect(evaluator.getValue('intensity', 0)).toBe(0.8)
  })
  
  it('clamps after last keyframe', () => {
    const curve = { keyframes: [{ timeMs: 0, value: 0 }, { timeMs: 1000, value: 1 }] }
    expect(evaluator.getValue('intensity', 2000)).toBe(1)
  })
  
  it('linear interpolation at midpoint', () => {
    const curve = { keyframes: [
      { timeMs: 0, value: 0, interpolation: 'linear' },
      { timeMs: 1000, value: 1, interpolation: 'linear' }
    ]}
    expect(evaluator.getValue('intensity', 500)).toBeCloseTo(0.5)
  })
  
  it('hold interpolation stays constant', () => {
    const curve = { keyframes: [
      { timeMs: 0, value: 0.8, interpolation: 'hold' },
      { timeMs: 1000, value: 0.2, interpolation: 'linear' }
    ]}
    expect(evaluator.getValue('intensity', 500)).toBe(0.8) // HOLD = step
    expect(evaluator.getValue('intensity', 1000)).toBe(0.2) // Jump at boundary
  })
  
  it('bezier ease-in starts slow', () => {
    const curve = { keyframes: [
      { timeMs: 0, value: 0, interpolation: 'bezier', bezierHandles: [0.42, 0, 1, 1] },
      { timeMs: 1000, value: 1 }
    ]}
    const earlyValue = evaluator.getValue('intensity', 200)
    expect(earlyValue).toBeLessThan(0.1) // Ease-in: slow start
  })
  
  it('cursor cache gives O(1) for forward playback', () => {
    // EvalÃºa 1000 frames secuenciales, verificar que no busca
    const start = performance.now()
    for (let t = 0; t < 10000; t += 10) {
      evaluator.getValue('intensity', t)
    }
    const elapsed = performance.now() - start
    expect(elapsed).toBeLessThan(5) // 1000 evaluaciones en <5ms
  })
  
  it('hue interpolation takes shortest path', () => {
    const curve = { keyframes: [
      { timeMs: 0, value: { h: 350, s: 100, l: 50 }, interpolation: 'linear' },
      { timeMs: 1000, value: { h: 10, s: 100, l: 50 } }
    ]}
    const mid = evaluator.getColorValue('color', 500)
    expect(mid.h).toBeCloseTo(0) // Goes through 360/0, not 180
  })
  
  it('overlay does not mutate raw output', () => {
    const rawOutput = { dimmerOverride: 0.8, intensity: 0.8 }
    const result = overlay.apply(rawOutput, 500)
    expect(rawOutput.dimmerOverride).toBe(0.8) // Original unchanged
  })
})
```

---

## 12. RESUMEN EJECUTIVO

### Â¿QuÃ© es Hephaestus?

Un sistema de automatizaciÃ³n multi-parÃ¡metro que se coloca **encima** del sistema de efectos existente sin tocarlo.

### Â¿QuÃ© cambia?

- **FXClip** â†’ puede llevar curvas de automatizaciÃ³n adjuntas
- **EffectManager** â†’ aplica overlay de curvas sobre el output de cualquier efecto
- **ChronosInjector** â†’ pasa curvas al EffectManager en el trigger

### Â¿QuÃ© NO cambia?

- Los 40+ efectos existentes
- BaseEffect
- HAL pipeline
- MasterArbiter
- DMX output

### Â¿QuÃ© puede hacer el usuario?

1. Abrir FX Creator
2. Elegir un efecto base (acid_sweep, strobe, etc.) o crear custom
3. Dibujar curvas para intensity, color, speed, pan, tilt, zoom, strobe...
4. Preview en tiempo real
5. Guardar como `.lfx`
6. Arrastrar al timeline de Chronos
7. El efecto se reproduce con las curvas de automatizaciÃ³n

### Â¿Por quÃ© es mejor que la competencia?

1. **Audio-bound curves** â†’ parÃ¡metros que reaccionan a la mÃºsica en tiempo real
2. **Overlay pattern** â†’ modula cualquier efecto sin modificarlo
3. **O(1) cursor cache** â†’ performance de 2Î¼s por evaluaciÃ³n
4. **Cubic bezier nativo** â†’ precisiÃ³n de After Effects, no easings de CSS
5. **Beat-relative timing** â†’ keyframes que se adaptan a cambios de BPM
6. **Relative/Additive modes** â†’ componer curvas sobre el comportamiento existente

---

*"El dios de la forja no destruye el acero existente. Lo toma, lo calienta, y lo moldea en algo que los mortales no creÃ­an posible."*

*- WAVE 2030.1: HEPHAESTUS CORE, el sistema de keyframes que los 40 efectos existentes merecen*

---

**NEXT**: WAVE 2030.2 â†’ ImplementaciÃ³n de `CurveEvaluator.ts` + tests  
**NEXT**: WAVE 2030.3 â†’ ImplementaciÃ³n del `CurveEditor.tsx` (SVG)  
**NEXT**: WAVE 2030.4 â†’ IntegraciÃ³n en EffectManager + ChronosInjector  
**NEXT**: WAVE 2030.5 â†’ FX Creator panel completo + `.lfx` IO
