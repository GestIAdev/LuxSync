# WAVE 2030.22: BUGFIX PACK üîß
## Audio Persistence + Curve Editor NaN Fix

**Fecha**: 2026-02-12  
**Estado**: ‚úÖ COMPLETADO  
**Tipo**: HOTFIX

---

## FILOSOF√çA

> *"Los bugs son deuda t√©cnica. Se pagan al contado, no a plazos."*

Dos hotfixes cr√≠ticos: uno afectaba la experiencia de usuario (sesi√≥n que no cargaba audio), el otro afectaba la herramienta de autor (curvas de color no renderizaban). Ambos violaban el Axioma Perfection First.

---

## BUG 1: AUDIO PERSISTENCE FAILURE

### S√≠ntoma:
Al salir de Chronos y volver, el `SessionStore` ten√≠a `audioRealPath` pero el audio NO se cargaba porque el `fetch()` fallaba silenciosamente.

### Root Cause:
En `ChronosLayout.tsx` l√≠nea 286, se hac√≠a:
```typescript
fetch(`file:///${session.audioRealPath.replace(/\\/g, '/')}`)
```

**Problemas m√∫ltiples**:
1. `fetch()` con `file://` URLs tiene restricciones CORS en Electron renderer process
2. Incluso con normalizaci√≥n de path, el fetch falla por security policy
3. Intentar recrear un `File` object desde blob para luego llamar `loadFile()` es indirecto

### Fix (v2 - WAVE 2030.22b):
Cambiar de `fetch()` + `loadFile()` a usar directamente `loadFromPath()` que ya existe en `useAudioLoaderPhantom`:

```typescript
// ‚öíÔ∏è WAVE 2030.22b: Use loadFromPath() instead of fetch() to avoid CORS issues
audioLoader.loadFromPath(session.audioRealPath)
  .then((result) => {
    if (result) {
      console.log('[SessionKeeper] ‚úÖ Audio restored successfully')
      if (session.playheadMs > 0) {
        streaming.seek(session.playheadMs)
      }
    }
  })
```

### ¬øPor qu√© esto funciona?
- `loadFromPath()` llama a `chronos:analyze-audio` IPC con `filePath`
- El main process lee el archivo con `fs.readFile` (sin restricciones CORS)
- El analysis se hace en PhantomWorker
- Se devuelve el Blob URL para streaming (construido en main process)
- Zero fetch(), zero CORS issues

---

## BUG 2: CURVE EDITOR NaN (Color Curves)

### S√≠ntoma:
Al crear curvas de tipo `color` (valueType: 'color'), el path SVG NO se renderizaba. Coordenadas resultaban en `NaN`.

### Root Cause (FINAL - after debug):
**El problema NO estaba en `toY()` o `buildCurvePath()`**. Estaba en la inicializaci√≥n del **drag state**:

```typescript
// ‚ùå ANTES (l√≠neas 364, 385):
setDrag({
  type: 'keyframe',
  index,
  startValue: kf.value as number,  // Si kf.value es {h,s,l} ‚Üí NaN
  ...
})
```

Cuando arrastraba un keyframe de curva de color:
1. `kf.value` es un objeto `{ h: number, s: number, l: number }`
2. El cast `as number` convierte objeto ‚Üí `NaN`
3. El `NaN` se guarda en `drag.startValue`
4. En `handleMouseMove`, se calcula: `newValue = drag.startValue + deltaYVal`
5. `newValue` = `NaN + n√∫mero` = `NaN`
6. Se llama a `toY(NaN)` ‚Üí `getPlotValue(NaN, 'color')` ‚Üí `NaN / 360` = `NaN`
7. Path SVG: `M x NaN` ‚Üí Error

### Fix:
Usar `getPlotValue()` en la inicializaci√≥n del drag para **ambos** tipos de curvas:

```typescript
// ‚úÖ DESPU√âS:
setDrag({
  type: 'keyframe',
  index,
  startValue: getPlotValue(kf.value, curve.valueType),  // 0-1 para color, directo para numeric
  ...
})
```

### Cambios completos:

| Ubicaci√≥n | Antes | Despu√©s |
|-----------|-------|---------|
| `handleKeyframeMouseDown` (l√≠nea 364) | `startValue: kf.value as number` | `startValue: getPlotValue(kf.value, curve.valueType)` |
| `handleBezierHandleMouseDown` (l√≠nea 385) | `startValue: kf.value as number` | `startValue: getPlotValue(kf.value, curve.valueType)` |
| Dependencies | Missing `curve.valueType` | Added to both callbacks |
| Dead code (l√≠nea 427-429) | Unused `kfPlotValue`, `nextKfPlotValue` | Removed |

### Debug Process:
1. **WAVE 2030.22**: Initial fix attempt - added `getPlotValue()` helper, refactored `toY()`
2. **WAVE 2030.22b**: Fixed audio persistence (unrelated)
3. **WAVE 2030.22c**: Added debug logging to find NaN source
4. **WAVE 2030.22d**: **Found root cause** via console log: `{value: NaN, plotValue: NaN}` traced back to drag initialization

### ¬øPor qu√© esto funciona ahora?
- **Color curves**: `getPlotValue({h,s,l}, 'color')` ‚Üí `h / 360` ‚Üí n√∫mero 0-1 v√°lido
- **Numeric curves**: `getPlotValue(number, 'number')` ‚Üí n√∫mero directo
- **Drag calculations**: Trabajan con n√∫meros reales (0-1 para color) en vez de NaN
- **Path rendering**: Todas las coordenadas son n√∫meros v√°lidos ‚Üí SVG renderiza correctamente

---

## ARCHIVOS MODIFICADOS

| Archivo | Cambio |
|---------|--------|
| `ChronosLayout.tsx` | Normalizaci√≥n de `audioRealPath` antes de `fetch()` |
| `CurveEditor.tsx` | +`getPlotValue()` helper, `toY()` refactor, removal de `as number` casts |

---

## VALIDACI√ìN

### BUG 1 (Audio Persistence):
1. Cargar audio en Chronos
2. Navegar a Dashboard
3. Volver a Chronos
4. **Antes**: audio no cargaba, consola mostraba fetch error
5. **Despu√©s**: audio carga autom√°ticamente desde path ‚úÖ

### BUG 2 (Color Curve NaN):
1. En Hephaestus Studio, crear curva de tipo `color`
2. A√±adir 2+ keyframes con HSL values
3. **Antes**: path SVG no renderizaba (coordenadas NaN)
4. **Despu√©s**: curva renderiza como l√≠nea suave basada en `hue` (H de HSL) ‚úÖ

---

## LECCIONES

1. **File URLs en Windows**: SIEMPRE normalizar paths a forward slashes antes de construir `file://` URLs
2. **Type casts en coord math**: Si un valor puede ser objeto OR n√∫mero, crear helpers tipados en vez de `as number` everywhere
3. **SVG debugging**: Si un path no renderiza, revisar si alguna coordenada es `NaN` ‚Äî SVG ignora todo el path si una coord es inv√°lida

---

**WAVE 2030.22: BUGFIX PACK ‚Äî SEALED.** üîß‚öíÔ∏è
