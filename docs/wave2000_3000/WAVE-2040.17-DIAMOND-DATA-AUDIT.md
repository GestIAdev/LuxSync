# âš’ï¸ğŸ’ WAVE 2040.17: THE DIAMOND DATA STRUCTURE
## AuditorÃ­a Completa de Integridad de Datos (.lux)

**Auditor:** PunkOpus (Core/Data Engineer)  
**Solicitante:** PunkGemini  
**Fecha:** 2026-02-13  
**Alcance:** Flujo completo Hephaestus â†’ Chronos â†’ .lux  
**Archivos Auditados:** 12 archivos core  

---

## ğŸ“‹ ÃNDICE

1. [Mapa del Flujo Completo](#1-mapa-del-flujo-completo)
2. [AuditorÃ­a de Ingesta (Clips Negros)](#2-auditorÃ­a-de-ingesta---el-problema-de-los-clips-negros)
3. [AuditorÃ­a de Estructura (TimelineClip)](#3-auditorÃ­a-de-estructura---timelineclipts)
4. [AuditorÃ­a de Persistencia (.lux JSON)](#4-auditorÃ­a-de-persistencia---lux-json)
5. [AuditorÃ­a del Modo REC (GrabaciÃ³n en Vivo)](#5-auditorÃ­a-del-modo-rec---grabaciÃ³n-en-vivo)
6. [Inventario de Problemas](#6-inventario-de-problemas)
7. [Lo Que Funciona Bien](#7-lo-que-funciona-bien)
8. [Soluciones Propuestas](#8-soluciones-propuestas)

---

## 1. MAPA DEL FLUJO COMPLETO

### 1A. MODO DISEÃ‘O (Drag & Drop desde Hephaestus)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  HEPHAESTUS VIEW (HephaestusView/index.tsx)                                â”‚
â”‚  â”œâ”€â”€ Library: LibraryClip[] (listados desde HephFileIO.listClips())        â”‚
â”‚  â”œâ”€â”€ handleDragStart() â†’ Construye DragPayload                            â”‚
â”‚  â”‚   payload = {                                                            â”‚
â”‚  â”‚     source: 'hephaestus',                                               â”‚
â”‚  â”‚     clipType: 'fx',                                                     â”‚
â”‚  â”‚     subType: 'heph-automation',                                          â”‚
â”‚  â”‚     defaultDurationMs: libraryItem.durationMs,                           â”‚
â”‚  â”‚     hephClipId: libraryItem.id,                                          â”‚
â”‚  â”‚     hephFilePath: libraryItem.filePath,                                  â”‚
â”‚  â”‚     name: libraryItem.name                                               â”‚
â”‚  â”‚   }                                                                      â”‚
â”‚  â”‚   âŒ FALTA: category, mixBus, tags, author, effectType                  â”‚
â”‚  â””â”€â”€ dataTransfer.setData('application/luxsync-fx', JSON.stringify(payload))â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚ D&D
                                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  TIMELINE CANVAS (TimelineCanvas.tsx)                                       â”‚
â”‚  â”œâ”€â”€ handleDrop() â†’ deserializeDragPayload()                               â”‚
â”‚  â””â”€â”€ Llama: onClipDrop(payload, timeMs, trackId)                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CHRONOS LAYOUT (ChronosLayout.tsx)                                         â”‚
â”‚  â”œâ”€â”€ handleClipDrop() â†’ clipState.createClipFromDrop(payload, timeMs, id)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  useTimelineClips.ts â†’ createClipFromDrop()                                 â”‚
â”‚  â”œâ”€â”€ if payload.source === 'hephaestus' && payload.hephFilePath:           â”‚
â”‚  â”‚   â””â”€â”€ createHephFXClip(name, filePath, time, duration, trackId, subType)â”‚
â”‚  â”‚       RESULTADO:                                                         â”‚
â”‚  â”‚       {                                                                  â”‚
â”‚  â”‚         id: 'clip-xxx',                                                  â”‚
â”‚  â”‚         type: 'fx',                                                      â”‚
â”‚  â”‚         fxType: 'pulse',    â† âŒ HARDCODED, no refleja tipo real        â”‚
â”‚  â”‚         label: name,                                                     â”‚
â”‚  â”‚         color: '#ff6b2b',   â† âŒ SIEMPRE EMBER, ignora mixBus/category â”‚
â”‚  â”‚         keyframes: [3 puntos bÃ¡sicos],  â† âŒ NO son las curvas reales  â”‚
â”‚  â”‚         params: { effectType: 'heph-automation' },                       â”‚
â”‚  â”‚         hephFilePath: filePath,                                          â”‚
â”‚  â”‚         isHephCustom: true,                                              â”‚
â”‚  â”‚         hephClip: undefined  â† âŒâŒ NUNCA SE LLENA                     â”‚
â”‚  â”‚       }                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PERSISTENCIA (.lux) â€” ChronosStore.ts                                      â”‚
â”‚  â”œâ”€â”€ useEffect syncs: clipState.clips â†’ project.updateFromSession(clips)   â”‚
â”‚  â”œâ”€â”€ project.timeline.clips = clips  â† âŒ REFERENCIA DIRECTA, no deep copyâ”‚
â”‚  â”œâ”€â”€ serializeProject() â†’ JSON.stringify(project, null, 2)                 â”‚
â”‚  â”‚                                                                          â”‚
â”‚  â”‚   âš ï¸ JSON.stringify con un Map<> produce {} vacÃ­o                       â”‚
â”‚  â”‚   Pero hephClip es undefined, asÃ­ que no hay Map en el JSON             â”‚
â”‚  â”‚   RESULTADO EN .lux:                                                     â”‚
â”‚  â”‚   {                                                                      â”‚
â”‚  â”‚     "id": "clip-xxx",                                                    â”‚
â”‚  â”‚     "type": "fx",                                                        â”‚
â”‚  â”‚     "fxType": "pulse",                                                   â”‚
â”‚  â”‚     "color": "#ff6b2b",                                                  â”‚
â”‚  â”‚     "keyframes": [...3 puntos falsos...],                                â”‚
â”‚  â”‚     "hephFilePath": "C:\\...\\effects\\nombre.lfx",                      â”‚
â”‚  â”‚     "isHephCustom": true                                                 â”‚
â”‚  â”‚     âŒ NO HAY hephClip (curvas reales)                                  â”‚
â”‚  â”‚     âŒ NO HAY mixBus                                                    â”‚
â”‚  â”‚     âŒ NO HAY category                                                  â”‚
â”‚  â”‚     âŒ NO HAY zones                                                     â”‚
â”‚  â”‚     âŒ NO HAY priority                                                  â”‚
â”‚  â”‚   }                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1B. MODO REC (GrabaciÃ³n en Vivo)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ChronosRecorder.ts                                                         â”‚
â”‚  â”œâ”€â”€ recordEffect(effectId) â†’ RecordedClip                                 â”‚
â”‚  â”‚   {                                                                      â”‚
â”‚  â”‚     id, clipType: 'fx', effectId, displayName,                          â”‚
â”‚  â”‚     startMs, durationMs, color, icon, trackId                           â”‚
â”‚  â”‚   }                                                                      â”‚
â”‚  â””â”€â”€ Emite: 'clip-added'                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ChronosLayout.tsx â†’ handleClipRecorded()                                   â”‚
â”‚  â”œâ”€â”€ Construye TimelineClip MANUALMENTE:                                   â”‚
â”‚  â”‚   {                                                                      â”‚
â”‚  â”‚     type: 'fx',                                                          â”‚
â”‚  â”‚     fxType: clip.effectId as any,  â† âŒ CAST PELIGROSO                 â”‚
â”‚  â”‚     keyframes: [],                  â† âŒ ARRAY VACÃO, no 3 puntos      â”‚
â”‚  â”‚     params: { intensity: 1.0 },     â† âš ï¸ Solo intensity                â”‚
â”‚  â”‚     label, startMs, endMs, color, trackId                               â”‚
â”‚  â”‚     âŒ NO HAY hephClip                                                  â”‚
â”‚  â”‚     âŒ NO HAY hephFilePath                                              â”‚
â”‚  â”‚     âŒ NO HAY isHephCustom                                              â”‚
â”‚  â”‚   }                                                                      â”‚
â”‚  â””â”€â”€ âš ï¸ El REC graba Arsenal FX, NO Hephaestus clips.                     â”‚
â”‚      Hephaestus solo entra por D&D. Esto es correcto.                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. AUDITORÃA DE INGESTA â€” EL PROBLEMA DE LOS CLIPS NEGROS

### ğŸ” DIAGNÃ“STICO

**Archivo:** `useTimelineClips.ts` â†’ `createClipFromDrop()`  
**Archivo:** `TimelineClip.ts` â†’ `createHephFXClip()`  

**El Bug:**  
Cuando un clip de Hephaestus llega a Chronos vÃ­a Drag & Drop, el `DragPayload` contiene:
- `source: 'hephaestus'` âœ…
- `hephFilePath: string` âœ…
- `name: string` âœ…
- `defaultDurationMs: number` âœ…

**Lo que FALTA en el DragPayload (nunca se envÃ­a desde HephaestusView):**
- `category` â€” Nunca se incluye
- `mixBus` â€” Nunca se incluye
- `tags` â€” Nunca se incluye
- `effectType` â€” Nunca se incluye (el clip real en .lfx tiene `effectType`)

**Consecuencia en `createHephFXClip()`:**

| Campo        | Valor Actual         | Valor Correcto                        | Estado |
|-------------|---------------------|--------------------------------------|--------|
| `fxType`    | `'pulse'` (hardcoded) | deberÃ­a inferirse del effectType     | âŒ BUG |
| `color`     | `'#ff6b2b'` (siempre ember) | deberÃ­a venir del mixBus/category | âŒ BUG |
| `hephClip`  | `undefined`          | deep copy de HephAutomationClip      | âŒâŒ CRÃTICO |
| `keyframes` | 3 puntos genÃ©ricos   | deberÃ­an reflejar las curvas reales   | âŒ BUG |

### ğŸ¨ MAPA DE COLORES ESPERADOS POR MIXBUS

El color del clip deberÃ­a coincidir con el track donde aterriza:

| MixBus    | Track | Color Track  | Color Clip Actual | Estado |
|-----------|-------|-------------|-------------------|--------|
| `global`  | FX1   | `#ef4444` (Rojo) | `#ff6b2b` (Ember) | âŒ NO MATCH |
| `htp`     | FX2   | `#f59e0b` (Orange) | `#ff6b2b` (Ember) | âš ï¸ Cercano |
| `ambient` | FX3   | `#10b981` (Green) | `#ff6b2b` (Ember) | âŒ NO MATCH |
| `accent`  | FX4   | `#3b82f6` (Blue) | `#ff6b2b` (Ember) | âŒ NO MATCH |

**Visual:** Todos los clips de Hephaestus aparecen con el mismo color ember naranja, sin importar en quÃ© track se colocan. Esto no solo es feo â€” es confuso porque el usuario pierde la identidad visual de su mezcla.

---

## 3. AUDITORÃA DE ESTRUCTURA â€” TimelineClip.ts

### ğŸ” DIAGNÃ“STICO

**La Pregunta CrÃ­tica:** Â¿Tiene el TimelineClip todo lo necesario para reproducirse sin depender del archivo `.lfx` original?

**Respuesta: âŒ NO.**

### CAMPOS DEL FXClip vs LO QUE NECESITA EL REPRODUCTOR

```typescript
// Lo que FXClip tiene HOY:
interface FXClip extends BaseClip {
  type: 'fx'
  fxType: FXType              // âŒ 'pulse' hardcoded para Heph
  label: string               // âœ… Nombre del clip
  color: string               // âŒ Siempre ember
  keyframes: FXKeyframe[]     // âŒ 3 puntos genÃ©ricos, NO las curvas reales
  params: Record<string, any> // âš ï¸ Solo { effectType: 'heph-automation' }
  hephClip?: HephAutomationClip  // âŒâŒ NUNCA SE LLENA
  hephFilePath?: string       // âœ… Pero esto crea DEPENDENCIA EXTERNA
  isHephCustom?: boolean      // âœ… True para Heph clips
}

// Lo que el REPRODUCTOR necesitarÃ¡:
// 1. Las curvas reales (HephAutomationClip.curves)
// 2. El mixBus para routing
// 3. Las zones para saber quÃ© fixtures afectar
// 4. El effectType para saber quÃ© efecto base usar
// 5. La priority para resoluciÃ³n de conflictos
// 6. Los staticParams para valores fijos
```

### ğŸ“Š ANÃLISIS: REFERENCIA vs VALOR

| Estrategia | Pro | Contra |
|-----------|-----|--------|
| **Referencia** (`hephFilePath` only) | .lux pequeÃ±o | Si borras/mueves el .lfx, el show se ROMPE |
| **Valor** (deep copy `hephClip`) | Show autÃ³nomo e inmutable | .lux mÃ¡s grande |

**DECISIÃ“N CORRECTA: VALOR (Deep Copy)**

Razones:
1. **Inmutabilidad del show:** Si editas el clip en Hephaestus despuÃ©s, tu show grabado no debe cambiar
2. **Portabilidad:** El .lux debe funcionar en otra mÃ¡quina sin necesitar los .lfx
3. **Grandma3 lo hace asÃ­:** Los cue stacks contienen los valores, no referencias a la library
4. **El hephFilePath es bonus:** Puede servir como "editar original" pero no como dependencia

### âš ï¸ PROBLEMA DE SERIALIZACIÃ“N: Map<>

`HephAutomationClip.curves` es un `Map<HephParamId, HephCurve>`.  
`JSON.stringify()` convierte `Map<>` a `{}` vacÃ­o.

**Ya existe soluciÃ³n:** `serializeHephClip()` / `deserializeHephClip()` en `types.ts`.  
Pero **NADIE LAS LLAMA** durante el flujo `TimelineClip â†’ .lux`.

El `serializeProject()` hace `JSON.stringify(project)` directo.  
Si `hephClip` tuviera un `Map<>`, se serializarÃ­a como `{}`.

**SoluciÃ³n:** El clip guardado en `FXClip.hephClip` debe almacenar la versiÃ³n **serializada** (`HephAutomationClipSerialized` con `Record<>` en vez de `Map<>`), o bien el `serializeProject` debe tener un custom replacer.

---

## 4. AUDITORÃA DE PERSISTENCIA â€” .lux JSON

### ğŸ” DIAGNÃ“STICO

**Archivo:** `ChronosProject.ts` â†’ `serializeProject()` / `deserializeProject()`

### SCHEMA CHECK: Â¿QuÃ© se guarda HOY?

```json
{
  "meta": {
    "version": "2.0",
    "author": "",
    "created": 1707840000000,
    "modified": 1707840000000,
    "durationMs": 180000,
    "name": "My Show"
  },
  "audio": {
    "name": "track.mp3",
    "path": "C:\\Music\\track.mp3",
    "bpm": 128,
    "offsetMs": 0,
    "durationMs": 180000
  },
  "timeline": {
    "clips": [
      {
        "id": "clip-1707840001-1",
        "type": "vibe",
        "vibeType": "techno-club",
        "label": "TECHNO CLUB",
        "startMs": 0,
        "endMs": 60000,
        "trackId": "vibe",
        "color": "#a855f7",
        "intensity": 1.0,
        "fadeInMs": 500,
        "fadeOutMs": 500
      },
      {
        "id": "clip-1707840002-2",
        "type": "fx",
        "fxType": "pulse",
        "label": "Laser Chase",
        "startMs": 30000,
        "endMs": 35000,
        "trackId": "fx1",
        "color": "#ff6b2b",
        "keyframes": [
          { "offsetMs": 0, "value": 0, "easing": "ease-in" },
          { "offsetMs": 2500, "value": 1, "easing": "ease-out" },
          { "offsetMs": 5000, "value": 0, "easing": "linear" }
        ],
        "params": { "effectType": "heph-automation" },
        "hephFilePath": "C:\\Users\\...\\effects\\laser-chase.lfx",
        "isHephCustom": true
      }
    ],
    "playheadMs": 0,
    "viewportStartMs": 0,
    "pixelsPerSecond": 100
  },
  "library": {
    "customEffects": [],
    "presets": []
  }
}
```

### PROBLEMAS ENCONTRADOS EN EL .lux

| # | Campo | Problema | Severidad |
|---|-------|----------|-----------|
| 1 | `hephClip` | **AUSENTE** â€” Las curvas reales nunca se guardan | ğŸ”´ CRÃTICO |
| 2 | `mixBus` | **AUSENTE** â€” No se puede rutear en reproducciÃ³n | ğŸ”´ CRÃTICO |
| 3 | `zones` | **AUSENTE** â€” No se sabe quÃ© fixtures afectar | ğŸ”´ CRÃTICO |
| 4 | `priority` | **AUSENTE** â€” No se puede resolver conflictos | ğŸŸ¡ ALTO |
| 5 | `effectType` | **AUSENTE** â€” Solo `params.effectType` como string suelto | ğŸŸ¡ ALTO |
| 6 | `category` | **AUSENTE** â€” No se puede filtrar/agrupar | ğŸŸ¡ MEDIO |
| 7 | `fxType` | `'pulse'` hardcoded â€” No refleja el tipo real | ğŸŸ¡ MEDIO |
| 8 | `color` | `'#ff6b2b'` hardcoded â€” No refleja mixBus | ğŸŸ¡ MEDIO |
| 9 | `keyframes` | 3 puntos genÃ©ricos â€” No son las curvas reales | ğŸŸ¡ ALTO |
| 10 | `hephFilePath` | Ruta ABSOLUTA a .lfx â€” No portable | ğŸŸ¡ MEDIO |

### CAMPOS QUE PODRÃAN SER `undefined` O `[object Object]`

- `hephClip`: Si alguien lo llenara con un `HephAutomationClip` que contiene `Map<>`, al serializar con `JSON.stringify` el campo `curves` se convertirÃ­a en `{}` vacÃ­o â†’ **DATA LOSS SILENCIOSA**.
- Actualmente no pasa porque `hephClip` es `undefined`. Pero cuando lo implementemos, este es un **landmine**.

### VALIDACIÃ“N DE PROYECTO: `validateProject()`

```typescript
// Lo que valida HOY:
âœ… project.meta exists
âœ… project.meta.version exists  
âœ… project.meta.name exists
âœ… project.timeline exists
âœ… project.timeline.clips is Array
âœ… Each clip has: id, type, startMs (number), endMs (number)

// Lo que NO valida:
âŒ clip.color (puede ser undefined)
âŒ clip.trackId (puede ser undefined)
âŒ clip.fxType (puede ser cualquier string)
âŒ clip.hephClip integrity (curves no vacÃ­as)
âŒ clip.keyframes (puede ser array vacÃ­o)
âŒ audio.path (puede ser string vacÃ­o '')
âŒ Rangos temporales (startMs < endMs, endMs <= durationMs)
```

---

## 5. AUDITORÃA DEL MODO REC â€” GRABACIÃ“N EN VIVO

### ğŸ” DIAGNÃ“STICO

**Archivo:** `ChronosRecorder.ts` + `ChronosLayout.tsx` (handleClipRecorded)

### FLUJO DE GRABACIÃ“N

1. Usuario pulsa REC â†’ `recorder.startRecording()`
2. Usuario clickea efecto en Arsenal â†’ `recorder.recordEffect(effectId)`
3. Recorder crea `RecordedClip` con color, trackId basado en MixBus routing
4. Emite `'clip-added'` â†’ ChronosLayout lo recibe
5. ChronosLayout construye `TimelineClip` **MANUALMENTE** (lÃ­neas ~523-546)

### PROBLEMAS MODO REC

| # | Problema | UbicaciÃ³n | Severidad |
|---|----------|-----------|-----------|
| 1 | `fxType: clip.effectId as any` â€” Cast peligroso sin validaciÃ³n | ChronosLayout.tsx:542 | ğŸŸ¡ MEDIO |
| 2 | `keyframes: []` â€” Array vacÃ­o, clip grabado sin keyframes | ChronosLayout.tsx:543 | ğŸŸ¡ MEDIO |
| 3 | No se graba hephClip ni hephFilePath (correcto â€” REC es solo Arsenal) | N/A | âœ… OK |
| 4 | Color viene de `RecordedClip.color` â€” el recorder SÃ lo asigna | ChronosRecorder.ts | âœ… OK |

### VEREDICTO MODO REC

**El modo REC es CORRECTO para clips de Arsenal.** Los clips grabados en vivo son efectos simples del Arsenal (strobe, sweep, chase) y NO necesitan curvas de Hephaestus. El recorder asigna correctamente:
- âœ… `trackId` basado en MixBus routing
- âœ… `color` desde EffectRegistry
- âœ… `displayName` desde EffectRegistry
- âœ… Quantize a beat grid

**Nota:** El REC **no soporta** clips de Hephaestus en vivo. Hephaestus solo entra por D&D en modo diseÃ±o. Esto es **correcto** conceptualmente â€” diseÃ±as tus curvas complejas en Heph y las colocas manualmente en el timeline.

---

## 6. INVENTARIO DE PROBLEMAS

### ğŸ”´ CRÃTICOS (Bloquean reproducciÃ³n futura)

| # | Problema | DescripciÃ³n |
|---|----------|-------------|
| **P1** | **hephClip NUNCA se llena** | `createHephFXClip()` no carga las curvas del .lfx. El clip queda como cascara vacÃ­a con solo `hephFilePath`. El reproductor no podrÃ¡ ejecutar las automatizaciones. |
| **P2** | **mixBus AUSENTE en TimelineClip** | El campo `mixBus` de `HephAutomationClip` nunca se transfiere al `FXClip`. El reproductor no sabrÃ¡ a quÃ© bus rutear. |
| **P3** | **zones AUSENTES en TimelineClip** | Las `EffectZone[]` del clip Heph nunca se transfieren. El reproductor no sabrÃ¡ quÃ© fixtures afectar. |
| **P4** | **SerializaciÃ³n Map<> = Data Loss** | Si se llenara `hephClip` con un `HephAutomationClip` que tiene `Map<>`, `JSON.stringify` lo destruirÃ­a. Necesita serializaciÃ³n custom. |

### ğŸŸ¡ ALTOS (Afectan UX/datos)

| # | Problema | DescripciÃ³n |
|---|----------|-------------|
| **P5** | **Color siempre ember** | `createHephFXClip()` hardcodea `#ff6b2b`. DeberÃ­a usar el color del track/mixBus. |
| **P6** | **fxType hardcoded 'pulse'** | No refleja el efectType real del clip Heph. |
| **P7** | **Keyframes genÃ©ricos** | 3 puntos (0â†’1â†’0) no representan las curvas reales. |
| **P8** | **DragPayload incompleto** | `handleDragStart()` en HephaestusView no envÃ­a category, mixBus, tags. |
| **P9** | **Ruta absoluta no portable** | `hephFilePath` es `C:\Users\...` â€” no funciona en otra mÃ¡quina. |
| **P10** | **validateProject() dÃ©bil** | No verifica integridad de clips Heph (curves no vacÃ­as, rangos temporales). |

### ğŸŸ¢ MENORES (CosmÃ©ticos/Mejoras)

| # | Problema | DescripciÃ³n |
|---|----------|-------------|
| **P11** | **`fxType` cast 'as any'** en REC | Cast peligroso sin validaciÃ³n de tipo. |
| **P12** | **library vacÃ­a** | `ProjectLibrary.customEffects` siempre `[]`. |
| **P13** | **author vacÃ­o** | `ProjectMeta.author` siempre `''`. |

---

## 7. LO QUE FUNCIONA BIEN

### âœ… CORRECTO

| # | Aspecto | DescripciÃ³n |
|---|---------|-------------|
| **F1** | **Drag & Drop Protocol** | El sistema D&D con MIME types (`luxsync-heph`, `luxsync-fx`, `luxsync-clip`) es sÃ³lido y extensible. |
| **F2** | **ClipRenderer Heph Detection** | `(clip as FXClip).isHephCustom` correctamente bifurca el renderizado entre FXClipContent y HephClipContent. |
| **F3** | **SerializaciÃ³n de .lfx** | `serializeHephClip()` / `deserializeHephClip()` manejan correctamente Map â†” Record. Ya existe la soluciÃ³n, solo falta usarla. |
| **F4** | **Auto-Save (Lazarus)** | Sistema robusto con checkpoints, recovery, localStorage fallback. |
| **F5** | **VibeClip completo** | Los clips de Vibe estÃ¡n 100% autocontenidos. Color, fadeIn/Out, intensity â€” todo presente. |
| **F6** | **Beat Grid Snapping** | El snap al beat funciona correctamente para ambos modos (D&D y REC). |
| **F7** | **Dirty State Tracking** | ComparaciÃ³n JSON para detectar cambios no guardados. |
| **F8** | **Project Version** | Sistema de versionado `'2.0'` con espacio para migraciÃ³n futura. |
| **F9** | **Blob URL Filter** | `updateFromSession()` correctamente filtra `blob:` URLs y solo guarda rutas reales. |
| **F10** | **REC MixBus Routing** | El recorder asigna tracks correctamente segÃºn MixBus (globalâ†’fx1, etc.). |

---

## 8. SOLUCIONES PROPUESTAS

### ğŸ”´ FIX P1: Inyectar hephClip al crear TimelineClip

**El problema central.** Cuando el usuario arrastra un clip de Hephaestus al timeline, necesitamos **cargar las curvas reales** del archivo `.lfx` y hacer deep copy.

```
FLUJO PROPUESTO:

1. handleDragStart() â†’ Incluir TODOS los metadatos en DragPayload
   (category, mixBus, tags, effectType, zones, priority)
   
2. createClipFromDrop() â†’ Detectar source === 'hephaestus'
   
3. OPCIÃ“N A (SÃ­ncrono): Incluir curvas serializadas en el DragPayload
   - Pro: No necesita IPC async
   - Contra: Payload puede ser ENORME si las curvas son densas
   
4. OPCIÃ“N B (Async con IPC): Cargar .lfx vÃ­a IPC despuÃ©s del drop
   - Pro: Payload ligero
   - Contra: Necesita IPC call async, posible delay
   
5. RECOMENDACIÃ“N: OPCIÃ“N A (curvas serializadas en payload)
   - Los .lfx tÃ­picos son <50KB
   - DataTransfer soporta payloads grandes
   - Zero latencia, zero IPC
```

**ImplementaciÃ³n concreta:**

```
EN HephaestusView/index.tsx â†’ handleDragStart():
  1. Leer el clip completo del .lfx (ya lo tenemos en memoria si estÃ¡ editÃ¡ndose,
     o cargarlo con window.luxsync.hephaestus.load())
  2. Serializarlo con serializeHephClip()
  3. Incluir el objeto serializado COMPLETO en el DragPayload

EN DragPayload (TimelineClip.ts):
  4. AÃ±adir campo: hephClipSerialized?: HephAutomationClipSerialized
  5. AÃ±adir campo: mixBus?: string
  6. AÃ±adir campo: category?: string

EN createHephFXClip (TimelineClip.ts):
  7. Aceptar hephClipSerialized como parÃ¡metro
  8. Almacenar en FXClip.hephClip como objeto serializado (Record, no Map)
  9. Derivar color del mixBus
  10. Derivar keyframes como resumen visual de la curva principal (intensity)
```

### ğŸ”´ FIX P2+P3: AÃ±adir mixBus y zones a FXClip

```typescript
// PROPUESTA: AÃ±adir campos a FXClip interface
interface FXClip extends BaseClip {
  // ... campos existentes ...
  
  /** WAVE 2040.17: MixBus routing (from Hephaestus) */
  mixBus?: 'global' | 'htp' | 'ambient' | 'accent'
  
  /** WAVE 2040.17: Effect zones (from Hephaestus) */
  zones?: string[]
  
  /** WAVE 2040.17: Effect priority (0-100) */
  priority?: number
}
```

### ğŸ”´ FIX P4: SerializaciÃ³n segura de hephClip

```
PROPUESTA: Guardar hephClip SIEMPRE como HephAutomationClipSerialized
(Record<> en vez de Map<>)

EN serializeProject():
  - AÃ±adir custom replacer para TimelineClip[] que:
    a) Si clip.hephClip es un HephAutomationClip con Map â†’ serializeHephClip()
    b) Si ya es HephAutomationClipSerialized (Record) â†’ dejar como estÃ¡

EN deserializeProject():
  - AÃ±adir post-processing para TimelineClip[] que:
    a) Si clip.hephClip existe â†’ mantener como Record (no convertir a Map)
    b) El reproductor usarÃ¡ Record directamente
    c) Solo convertir a Map cuando se necesite editar en Hephaestus

ALTERNATIVA MÃS LIMPIA:
  Que FXClip.hephClip sea SIEMPRE HephAutomationClipSerialized (Record).
  Nunca guardar Map<> en el timeline. Las funciones de evaluaciÃ³n de curvas
  deberÃ­an aceptar Record o Map.
```

### ğŸŸ¡ FIX P5: Color dinÃ¡mico por MixBus

```typescript
// PROPUESTA: Mapa de colores por MixBus (coherente con tracks)
const MIXBUS_CLIP_COLORS: Record<string, string> = {
  'global':  '#ef4444',  // Rojo (match FX1 track)
  'htp':     '#f59e0b',  // Orange (match FX2 track)
  'ambient': '#10b981',  // Green (match FX3 track)
  'accent':  '#3b82f6',  // Blue (match FX4 track)
}

// EN createHephFXClip():
const color = MIXBUS_CLIP_COLORS[mixBus] || '#ff6b2b' // Fallback ember
```

### ğŸŸ¡ FIX P8: DragPayload completo desde Hephaestus

```
EN HephaestusView/index.tsx â†’ handleDragStart():

// ACTUAL (incompleto):
const payload = {
  source: 'hephaestus',
  clipType: 'fx',
  subType: 'heph-automation',
  defaultDurationMs: libraryItem.durationMs,
  hephClipId: libraryItem.id,
  hephFilePath: libraryItem.filePath,
  name: libraryItem.name
}

// PROPUESTO (completo):
const payload = {
  source: 'hephaestus',
  clipType: 'fx',
  subType: libraryItem.category || 'heph-automation',
  defaultDurationMs: libraryItem.durationMs,
  hephClipId: libraryItem.id,
  hephFilePath: libraryItem.filePath,
  name: libraryItem.name,
  // NUEVOS CAMPOS:
  category: libraryItem.category,
  mixBus: // necesita aÃ±adirse a LibraryClip/HephClipMetadata
  effectType: libraryItem.effectType,
  // hephClipSerialized: // cargar clip completo
}

NOTA: LibraryClip carece de `mixBus`. HephClipMetadata (HephFileIO) tambiÃ©n.
Se necesita aÃ±adir `mixBus` a HephClipMetadata.listClips().
```

### ğŸŸ¡ FIX P9: Ruta relativa para portabilidad

```
PROPUESTA:
- Guardar hephFilePath como nombre de archivo relativo: "laser-chase.lfx"
- El reproductor buscarÃ¡ en: userData/effects/{filename}
- Si no encuentra, buscar en la ruta absoluta como fallback
- Con la propuesta P1 (deep copy), hephFilePath se vuelve OPCIONAL
  (solo para "editar original en Hephaestus")
```

### ğŸŸ¡ FIX P10: ValidaciÃ³n robusta

```typescript
// PROPUESTA: Expandir validateProject()
function validateProject(project: LuxProject): { valid: boolean; errors: string[]; warnings: string[] } {
  // ... validaciones existentes ...
  
  // Nuevas validaciones:
  project.timeline.clips.forEach((clip, i) => {
    // Rangos temporales
    if (clip.startMs >= clip.endMs) errors.push(`Clip ${i}: startMs >= endMs`)
    if (clip.startMs < 0) errors.push(`Clip ${i}: negative startMs`)
    
    // TrackId
    if (!clip.trackId) warnings.push(`Clip ${i}: missing trackId`)
    
    // Heph clips
    if (clip.type === 'fx') {
      const fx = clip as FXClip
      if (fx.isHephCustom && !fx.hephClip) {
        warnings.push(`Clip ${i}: Heph custom but missing hephClip curves`)
      }
      if (fx.isHephCustom && fx.hephClip) {
        const curveCount = Object.keys(fx.hephClip.curves || {}).length
        if (curveCount === 0) {
          errors.push(`Clip ${i}: Heph clip has 0 curves â€” empty automation`)
        }
      }
    }
  })
}
```

---

## 9. PRIORIDAD DE IMPLEMENTACIÃ“N

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  FASE 1: FOUNDATION (Lo que rompe el show)                                  â”‚
â”‚  â”œâ”€â”€ P1: Inyectar hephClip con deep copy de curvas                         â”‚
â”‚  â”œâ”€â”€ P2: AÃ±adir mixBus a FXClip                                           â”‚
â”‚  â”œâ”€â”€ P3: AÃ±adir zones a FXClip                                            â”‚
â”‚  â”œâ”€â”€ P4: SerializaciÃ³n segura (Record, no Map)                             â”‚
â”‚  â””â”€â”€ P5: Color dinÃ¡mico por MixBus                                        â”‚
â”‚                                                                             â”‚
â”‚  FASE 2: POLISH (Lo que mejora la experiencia)                              â”‚
â”‚  â”œâ”€â”€ P8: DragPayload completo con metadatos                               â”‚
â”‚  â”œâ”€â”€ P6: fxType correcto (no hardcoded 'pulse')                            â”‚
â”‚  â”œâ”€â”€ P7: Keyframes como resumen visual de la curva real                    â”‚
â”‚  â””â”€â”€ P10: ValidaciÃ³n robusta de proyecto                                   â”‚
â”‚                                                                             â”‚
â”‚  FASE 3: FUTURE-PROOF (Para cuando hagamos el reproductor)                 â”‚
â”‚  â”œâ”€â”€ P9: Rutas relativas para portabilidad                                 â”‚
â”‚  â”œâ”€â”€ P12: Library con custom effects del proyecto                          â”‚
â”‚  â””â”€â”€ P13: Author metadata                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 10. FORMATO .lux IDEAL (POST-FIX)

```json
{
  "meta": {
    "version": "2.1",
    "author": "Radwulf",
    "created": 1707840000000,
    "modified": 1707840000000,
    "durationMs": 180000,
    "name": "RAVE NIGHT 2026"
  },
  "audio": {
    "name": "dark-techno-set.mp3",
    "path": "C:\\Music\\dark-techno-set.mp3",
    "bpm": 138,
    "offsetMs": 0,
    "durationMs": 180000
  },
  "timeline": {
    "clips": [
      {
        "id": "clip-1707840001-1",
        "type": "vibe",
        "vibeType": "techno-club",
        "label": "TECHNO CLUB",
        "startMs": 0,
        "endMs": 60000,
        "trackId": "vibe",
        "color": "#a855f7",
        "intensity": 1.0,
        "fadeInMs": 500,
        "fadeOutMs": 500
      },
      {
        "id": "clip-1707840002-2",
        "type": "fx",
        "fxType": "heph-custom",
        "label": "Laser Chase v2",
        "startMs": 30000,
        "endMs": 35000,
        "trackId": "fx1",
        "color": "#ef4444",
        "isHephCustom": true,
        "mixBus": "global",
        "zones": ["stage-left", "stage-right"],
        "priority": 80,
        "hephFilePath": "laser-chase-v2.lfx",
        "hephClip": {
          "id": "heph-lz1abc-f0e2",
          "name": "Laser Chase v2",
          "author": "Radwulf",
          "category": "movement",
          "tags": ["laser", "chase", "fast"],
          "vibeCompat": ["techno-club"],
          "zones": ["stage-left", "stage-right"],
          "mixBus": "global",
          "priority": 80,
          "durationMs": 5000,
          "effectType": "heph_custom",
          "curves": {
            "intensity": {
              "paramId": "intensity",
              "valueType": "number",
              "range": [0, 1],
              "defaultValue": 0,
              "mode": "absolute",
              "keyframes": [
                { "timeMs": 0, "value": 0, "interpolation": "bezier", "bezierHandles": [0.42, 0, 1, 1] },
                { "timeMs": 500, "value": 1, "interpolation": "hold" },
                { "timeMs": 2500, "value": 0.8, "interpolation": "bezier", "bezierHandles": [0, 0, 0.58, 1] },
                { "timeMs": 4500, "value": 0.3, "interpolation": "linear" },
                { "timeMs": 5000, "value": 0, "interpolation": "hold" }
              ]
            },
            "pan": {
              "paramId": "pan",
              "valueType": "number",
              "range": [0, 1],
              "defaultValue": 0.5,
              "mode": "absolute",
              "keyframes": [
                { "timeMs": 0, "value": 0, "interpolation": "linear" },
                { "timeMs": 2500, "value": 1, "interpolation": "linear" },
                { "timeMs": 5000, "value": 0, "interpolation": "linear" }
              ]
            }
          },
          "staticParams": { "speed": 0.7 }
        },
        "keyframes": [
          { "offsetMs": 0, "value": 0, "easing": "ease-in" },
          { "offsetMs": 500, "value": 1, "easing": "linear" },
          { "offsetMs": 2500, "value": 0.8, "easing": "ease-out" },
          { "offsetMs": 4500, "value": 0.3, "easing": "linear" },
          { "offsetMs": 5000, "value": 0, "easing": "linear" }
        ],
        "params": {}
      }
    ],
    "playheadMs": 0,
    "viewportStartMs": 0,
    "pixelsPerSecond": 100
  },
  "library": {
    "customEffects": [],
    "presets": []
  }
}
```

**El show es la joya. El .lux es el cofre que la protege. Debe ser perfecto.**

---

*"Si Grandma3 puede, nosotros podemos. Y lo hacemos con mÃ¡s estilo."*  
â€” PunkOpus, WAVE 2040.17

