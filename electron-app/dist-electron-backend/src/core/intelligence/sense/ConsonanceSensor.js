// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  üéß CONSONANCE SENSOR - El O√≠do que Escucha la Coherencia
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  WAVE 500 - PROJECT GENESIS - PHASE 2
//  "Qu√© tan bien fluye un estado al siguiente"
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// CONSTANTES - Teor√≠a de intervalos simplificada
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
/**
 * Pesos de consonancia para intervalos crom√°ticos (distancia en hue)
 * Basado en teor√≠a musical aplicada a color
 *
 * 0¬∞ = Un√≠sono (mismo color) = perfecta consonancia
 * 30¬∞ = An√°logo = muy consonante
 * 60¬∞ = Tri√°dico parcial = consonante
 * 90¬∞ = Cuadrado parcial = tensi√≥n moderada
 * 120¬∞ = Tri√°dico = consonante
 * 150¬∞ = Split-complementario = tensi√≥n sofisticada
 * 180¬∞ = Complementario = m√°xima tensi√≥n (pero arm√≥nica)
 */
const HUE_CONSONANCE_MAP = [
    { angle: 0, consonance: 1.0, name: 'unison' },
    { angle: 30, consonance: 0.85, name: 'analogous' },
    { angle: 60, consonance: 0.75, name: 'split-triadic' },
    { angle: 90, consonance: 0.55, name: 'square-partial' },
    { angle: 120, consonance: 0.70, name: 'triadic' },
    { angle: 150, consonance: 0.60, name: 'split-complementary' },
    { angle: 180, consonance: 0.50, name: 'complementary' },
];
let previousState = null;
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// FUNCIONES P√öBLICAS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
/**
 * Analiza la consonancia entre el estado actual y el anterior
 *
 * @param currentPalette - Paleta actual
 * @param currentPattern - Patr√≥n musical actual
 * @returns An√°lisis de consonancia
 */
export function senseConsonance(currentPalette, currentPattern) {
    const timestamp = currentPattern.timestamp;
    // Si no hay estado anterior, asumimos consonancia perfecta
    if (!previousState) {
        previousState = {
            palette: currentPalette,
            pattern: currentPattern,
            timestamp,
        };
        return {
            totalConsonance: 1.0,
            chromaticConsonance: 1.0,
            rhythmicConsonance: 1.0,
            emotionalConsonance: 1.0,
            dominantInterval: 'unison',
            transitionType: 'smooth',
            suggestedTransitionMs: 500,
            timestamp,
        };
    }
    // Calcular componentes
    const chromatic = calculateChromaticConsonance(previousState.palette, currentPalette);
    const rhythmic = calculateRhythmicConsonance(previousState.pattern, currentPattern);
    const emotional = calculateEmotionalConsonance(previousState.pattern, currentPattern);
    // Pesos (ritmo y emoci√≥n pesan m√°s que color puro)
    const weights = {
        chromatic: 0.30,
        rhythmic: 0.35,
        emotional: 0.35,
    };
    const totalConsonance = chromatic.consonance * weights.chromatic +
        rhythmic * weights.rhythmic +
        emotional * weights.emotional;
    // Determinar tipo de transici√≥n y velocidad sugerida
    const transitionType = categorizeTransition(totalConsonance);
    const suggestedTransitionMs = calculateTransitionSpeed(totalConsonance, currentPattern);
    // Actualizar estado anterior
    previousState = {
        palette: currentPalette,
        pattern: currentPattern,
        timestamp,
    };
    return {
        totalConsonance,
        chromaticConsonance: chromatic.consonance,
        rhythmicConsonance: rhythmic,
        emotionalConsonance: emotional,
        dominantInterval: chromatic.intervalName,
        transitionType,
        suggestedTransitionMs,
        timestamp,
    };
}
/**
 * Eval√∫a la consonancia de un cambio de hue propuesto
 *
 * @param currentHue - Hue actual (0-360)
 * @param proposedHue - Hue propuesto (0-360)
 * @returns Score de consonancia (0-1)
 */
export function evaluateHueChange(currentHue, proposedHue) {
    let distance = Math.abs(currentHue - proposedHue);
    if (distance > 180)
        distance = 360 - distance;
    return getConsonanceForDistance(distance);
}
/**
 * Sugiere el mejor hue consonante dado un hue actual y un objetivo de consonancia
 *
 * @param currentHue - Hue actual
 * @param targetConsonance - Consonancia objetivo (0-1)
 * @returns Array de hues sugeridos ordenados por consonancia
 */
export function suggestConsonantHues(currentHue, targetConsonance) {
    // Encontrar intervalos con consonancia cercana al target
    const candidates = HUE_CONSONANCE_MAP
        .filter(i => Math.abs(i.consonance - targetConsonance) < 0.2)
        .sort((a, b) => Math.abs(a.consonance - targetConsonance) - Math.abs(b.consonance - targetConsonance));
    if (candidates.length === 0) {
        // Si no hay match, usar an√°logo
        return [(currentHue + 30) % 360, (currentHue - 30 + 360) % 360];
    }
    // Generar hues en ambas direcciones para cada intervalo
    const suggestions = [];
    for (const interval of candidates.slice(0, 3)) {
        suggestions.push((currentHue + interval.angle) % 360);
        if (interval.angle !== 0 && interval.angle !== 180) {
            suggestions.push((currentHue - interval.angle + 360) % 360);
        }
    }
    return suggestions;
}
/**
 * Resetea estado de consonancia
 */
export function resetConsonanceState() {
    previousState = null;
}
function calculateChromaticConsonance(prevPalette, currPalette) {
    // Comparar hues primarios
    const prevHue = prevPalette.primary?.h ?? 0;
    const currHue = currPalette.primary?.h ?? 0;
    let distance = Math.abs(prevHue - currHue);
    if (distance > 180)
        distance = 360 - distance;
    // Buscar intervalo m√°s cercano
    let bestMatch = HUE_CONSONANCE_MAP[0];
    let bestDelta = 180;
    for (const interval of HUE_CONSONANCE_MAP) {
        const delta = Math.abs(distance - interval.angle);
        if (delta < bestDelta) {
            bestDelta = delta;
            bestMatch = interval;
        }
    }
    // Ajustar consonancia por qu√© tan cerca estamos del intervalo ideal
    const proximityBonus = Math.exp(-bestDelta / 20); // M√°s cerca = m√°s bonus
    const adjustedConsonance = bestMatch.consonance * (0.7 + 0.3 * proximityBonus);
    return {
        consonance: Math.min(1, adjustedConsonance),
        intervalName: bestMatch.name,
    };
}
function calculateRhythmicConsonance(prevPattern, currPattern) {
    // Consonancia r√≠tmica = qu√© tan suave es el cambio de energ√≠a
    // 1. Cambio de BPM (grande = disonante)
    const bpmDelta = Math.abs(prevPattern.bpm - currPattern.bpm);
    const bpmConsonance = Math.exp(-bpmDelta / 20); // 20 BPM de tolerancia
    // 2. Cambio de intensidad r√≠tmica
    const intensityDelta = Math.abs(prevPattern.rhythmicIntensity - currPattern.rhythmicIntensity);
    const intensityConsonance = 1 - intensityDelta; // Lineal
    // 3. Cambio de secci√≥n (cambio de secci√≥n = naturalmente menos consonante)
    const sectionConsonance = prevPattern.section === currPattern.section ? 1.0 : 0.6;
    // 4. Coherencia de direcci√≥n (ambos building o ambos releasing = consonante)
    let directionConsonance = 0.7; // Default neutral
    if (prevPattern.isBuilding === currPattern.isBuilding)
        directionConsonance = 1.0;
    if (prevPattern.isReleasing === currPattern.isReleasing)
        directionConsonance = 1.0;
    // Cambio de direcci√≥n = disonancia natural (pero esperada)
    if (prevPattern.isBuilding && currPattern.isReleasing)
        directionConsonance = 0.5;
    if (prevPattern.isReleasing && currPattern.isBuilding)
        directionConsonance = 0.5;
    // Combinar
    return (bpmConsonance * 0.2 +
        intensityConsonance * 0.3 +
        sectionConsonance * 0.25 +
        directionConsonance * 0.25);
}
function calculateEmotionalConsonance(prevPattern, currPattern) {
    // Consonancia emocional = coherencia en la tensi√≥n
    // 1. Cambio de tensi√≥n emocional
    const tensionDelta = Math.abs(prevPattern.emotionalTension - currPattern.emotionalTension);
    const tensionConsonance = 1 - tensionDelta;
    // 2. Cambio de fase de energ√≠a
    const phaseConsonance = prevPattern.energyPhase === currPattern.energyPhase ? 1.0 : 0.6;
    // 3. Coherencia de densidad arm√≥nica
    const densityDelta = Math.abs(prevPattern.harmonicDensity - currPattern.harmonicDensity);
    const densityConsonance = 1 - densityDelta;
    // 4. Drop handling especial
    // Entrar o salir de drop es naturalmente disonante pero necesario
    let dropConsonance = 1.0;
    if (prevPattern.isDropActive !== currPattern.isDropActive) {
        dropConsonance = 0.4; // Cambio de drop = disonancia fuerte (pero intencionada)
    }
    return (tensionConsonance * 0.35 +
        phaseConsonance * 0.25 +
        densityConsonance * 0.20 +
        dropConsonance * 0.20);
}
function getConsonanceForDistance(distance) {
    // Buscar entre los intervalos conocidos
    let bestMatch = HUE_CONSONANCE_MAP[0];
    let bestDelta = 180;
    for (const interval of HUE_CONSONANCE_MAP) {
        const delta = Math.abs(distance - interval.angle);
        if (delta < bestDelta) {
            bestDelta = delta;
            bestMatch = interval;
        }
    }
    // Ajustar por proximidad
    const proximityFactor = Math.exp(-bestDelta / 15);
    return bestMatch.consonance * proximityFactor;
}
function categorizeTransition(consonance) {
    if (consonance >= 0.7)
        return 'smooth';
    if (consonance >= 0.4)
        return 'moderate';
    return 'abrupt';
}
function calculateTransitionSpeed(consonance, pattern) {
    // Base speed seg√∫n consonancia
    // Alta consonancia = transici√≥n lenta y elegante
    // Baja consonancia = transici√≥n r√°pida (el cambio ya es abrupto, no lo prolonguemos)
    let baseMs = 500; // Default
    if (consonance >= 0.8) {
        baseMs = 800; // Muy suave = slow crossfade
    }
    else if (consonance >= 0.6) {
        baseMs = 500; // Normal
    }
    else if (consonance >= 0.4) {
        baseMs = 300; // Moderado = m√°s r√°pido
    }
    else {
        baseMs = 150; // Abrupto = muy r√°pido (o instant√°neo)
    }
    // Ajustar por urgencia del momento musical
    if (pattern.isDropActive) {
        baseMs = Math.min(baseMs, 100); // En drop = instant√°neo
    }
    else if (pattern.section === 'drop' || pattern.section === 'chorus') {
        baseMs = Math.min(baseMs, 250); // Alta energ√≠a = r√°pido
    }
    else if (pattern.section === 'verse' || pattern.section === 'breakdown') {
        baseMs = Math.max(baseMs, 600); // Baja energ√≠a = lento
    }
    // Ajustar por BPM (tempo r√°pido = transiciones m√°s r√°pidas)
    const bpmFactor = pattern.bpm > 140 ? 0.8 : pattern.bpm < 100 ? 1.2 : 1.0;
    return Math.round(baseMs * bpmFactor);
}
