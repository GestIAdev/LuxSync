# ğŸ‘» WAVE 2005.3: THE PHANTOM WORKER

**Fecha**: 2026-02-09  
**Tipo**: Arquitectura Anti-Crash  
**Estado**: âœ… IMPLEMENTADO  

---

## ğŸ¯ PROBLEMA ORIGINAL

El renderer de Chronos crasheaba al cargar archivos de audio de apenas 1.88MB:
- `decodeAudioData()` consumÃ­a toda la memoria del renderer
- Three.js corrÃ­a a 60fps al mismo tiempo
- TitanOrchestrator a 30fps
- AudioWorklet procesando en paralelo
- **OOM inevitable**

---

## ğŸ’¡ SOLUCIÃ“N: OPTION E - HIDDEN RENDERER WORKER

Propuesta por Radwulf (el arquitecto). Una BrowserWindow **invisible** que procesa audio de manera aislada.

### Â¿Por quÃ© es genial?

1. **Zero dependencias externas** - No FFmpeg, no node-web-audio-api
2. **Usa Chromium nativo** - AudioContext que ya tenemos
3. **Aislamiento total** - Si Phantom crashea, la UI sigue viva
4. **Memoria separada** - El renderer principal nunca ve el AudioBuffer pesado
5. **Soporta CUALQUIER tamaÃ±o** - Solo limitado por disco

---

## ğŸ“ ARCHIVOS CREADOS/MODIFICADOS

### Nuevos:
```
electron/workers/PhantomWorkerManager.ts  (~330 lÃ­neas)
â”œâ”€â”€ Gestiona BrowserWindow({ show: false })
â”œâ”€â”€ Lee archivos con fs.readFile()
â”œâ”€â”€ EnvÃ­a buffer al Phantom
â”œâ”€â”€ Maneja crash recovery automÃ¡tico
â””â”€â”€ Timeout de 5 minutos para archivos enormes

electron/workers/phantomWorker.html  (~530 lÃ­neas)
â”œâ”€â”€ Entry point para el Phantom
â”œâ”€â”€ Analyzer completo embebido (GodEarOffline-style)
â”œâ”€â”€ AudioContext nativo de Chromium
â”œâ”€â”€ EnvÃ­a resultados vÃ­a IPC
â””â”€â”€ UI de debug (invisible pero Ãºtil)

electron/ipc/ChronosIPCHandlers.ts  (~230 lÃ­neas)
â”œâ”€â”€ chronos:analyze-audio - Handler principal
â”œâ”€â”€ chronos:save-temp-audio - Para drag-drop
â”œâ”€â”€ chronos:cleanup-temp-audio - Limpieza
â””â”€â”€ Temp file management en %TEMP%

src/chronos/hooks/useAudioLoaderPhantom.ts  (~310 lÃ­neas)
â”œâ”€â”€ Hook de React para cargar audio
â”œâ”€â”€ Usa window.luxsync.chronos API
â”œâ”€â”€ Maneja progress updates
â”œâ”€â”€ Crea blob URL para playback
â””â”€â”€ Cleanup automÃ¡tico
```

### Modificados:
```
electron/main.ts
â”œâ”€â”€ Import PhantomWorkerManager
â”œâ”€â”€ Init en initTitan()
â”œâ”€â”€ Cleanup en before-quit
â””â”€â”€ setupChronosIPCHandlers()

electron/preload.ts
â”œâ”€â”€ Nuevo objeto 'chronos' en api
â”œâ”€â”€ analyzeAudio(request)
â”œâ”€â”€ onProgress/onComplete/onError
â””â”€â”€ PatrÃ³n subscribe/unsubscribe

src/chronos/ui/ChronosLayout.tsx
â””â”€â”€ Cambiado useAudioLoader â†’ useAudioLoaderPhantom

package.json
â”œâ”€â”€ npm run copy:phantom (copia HTML al dist)
â”œâ”€â”€ extraResources para electron-builder
â””â”€â”€ Build process actualizado
```

---

## ğŸ”„ FLUJO DE DATOS

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ RENDERER (ChronosLayout)                                        â”‚
â”‚                                                                 â”‚
â”‚   1. User drops audio file                                     â”‚
â”‚   2. useAudioLoaderPhantom.loadFile(file)                      â”‚
â”‚   3. Read file as ArrayBuffer                                  â”‚
â”‚   4. IPC invoke â†’ chronos:analyze-audio                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ MAIN PROCESS (ChronosIPCHandlers)                               â”‚
â”‚                                                                 â”‚
â”‚   5. Save to temp file (if buffer)                             â”‚
â”‚   6. Forward to PhantomWorkerManager                           â”‚
â”‚   7. Wait for result                                           â”‚
â”‚   8. Cleanup temp file                                         â”‚
â”‚   9. Return result to renderer                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PHANTOM WORKER (Hidden BrowserWindow)                           â”‚
â”‚                                                                 â”‚
â”‚   A. Receive 'phantom:analyze' with buffer                     â”‚
â”‚   B. AudioContext.decodeAudioData() â† CHROMIUM NATIVE          â”‚
â”‚   C. Run embedded analyzer (waveform, energy, beats, sections) â”‚
â”‚   D. Send progress updates â†’ Main â†’ Renderer                   â”‚
â”‚   E. Send 'phantom:analysis-complete' with JSON result         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ›¡ï¸ CRASH RESILIENCE

Si el Phantom crashea durante anÃ¡lisis:
1. `webContents.on('crashed')` detecta el crash
2. Todas las pending requests son rejected
3. Phantom se reinicia automÃ¡ticamente
4. UI recibe error, puede reintentar
5. **La UI NUNCA crashea**

---

## ğŸ“Š ANÃLISIS EMBEBIDO

El Phantom incluye anÃ¡lisis completo:

| Fase | DescripciÃ³n |
|------|-------------|
| `loading` | Recibir buffer |
| `decoding` | AudioContext.decodeAudioData |
| `waveform` | Extract peaks/RMS (100 samples/sec) |
| `energy` | Compute energy heatmap |
| `beats` | Detect beat grid |
| `sections` | Identify song sections |
| `transients` | Find snap points |
| `complete` | Return JSON |

---

## ğŸµ PLAYBACK STRATEGY

El buffer **no se envÃ­a de vuelta** al renderer.

- Renderer crea `new Blob([buffer])` localmente
- Crea `URL.createObjectURL(blob)` para `<audio>`
- Streaming desde disco, no desde RAM
- Cleanup on reset()

---

## ğŸ”§ BUILD CONFIGURATION

```json
// package.json
{
  "scripts": {
    "copy:phantom": "node -e \"require('fs').copyFileSync('electron/workers/phantomWorker.html', 'dist-electron/phantomWorker.html')\""
  },
  "build": {
    "extraResources": [
      {
        "from": "dist-electron/phantomWorker.html",
        "to": "phantomWorker.html"
      }
    ]
  }
}
```

---

## ğŸ“ LOGS ESPERADOS

```
[PhantomWorker] ğŸ‘» Manager created
[PhantomWorker] ğŸ‘» Initializing hidden worker...
[PhantomWorker] âœ… Found at: .../dist-electron/phantomWorker.html
[PhantomWorker] ğŸ‘» Phantom signals ready
[PhantomWorker] ğŸ‘» Phantom ready for audio processing!
[ChronosIPC] ğŸ§ Setting up Chronos IPC handlers...
[ChronosIPC] âœ… Chronos IPC handlers ready
[Main] ğŸ‘» Phantom Worker initialized (WAVE 2005.3)
```

---

## ğŸš€ NEXT STEPS

- [ ] Test con archivo de 1.88MB (el que crasheaba)
- [ ] Test con archivo de 50MB
- [ ] Test con archivo de 200MB (sesiÃ³n de 2 horas)
- [ ] Verificar memory usage del renderer durante anÃ¡lisis
- [ ] Verificar que UI sigue responsive

---

## ğŸ¤˜ FILOSOFÃA PUNK

> "Zero external dependencies. We use what Chromium gives us.
> If it crashes, it crashes alone.
> The show must go on."

â€” Option E, diseÃ±ada por Radwulf

---

**WAVE 2005.3: THE PHANTOM WORKER**  
*Because audio processing shouldn't kill your UI*
