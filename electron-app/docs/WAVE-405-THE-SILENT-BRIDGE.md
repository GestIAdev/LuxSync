# üîç WAVE 405: OPERACI√ìN "THE SILENT BRIDGE" - Auditor√≠a de Conectividad

```
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù    ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë       ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  
‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë       ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë       ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù   ‚ïö‚ïê‚ïù       ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
                                                                                                
  Connectivity Forensics: Why Backend Has 0 Fixtures When Frontend Has 10
  Author: PunkOpus & Radwulf | Date: Enero 14, 2026
```

---

## üìã SITUACI√ìN CR√çTICA

**REPORTE DE INCIDENTE:**
- **Frontend:** 10 fixtures visibles (StageConstructorView - idle gray circles)
- **Backend:** 0 fixtures (TitanEngine no tiene patch)
- **S√≠ntoma:** Show se guarda en disco, pero propagaci√≥n a memoria de ejecuci√≥n FALLA SILENCIOSAMENTE
- **Impacto:** El motor de iluminaci√≥n no sabe que existen fixtures

**HIP√ìTESIS INICIAL:**
> "Si el Bridge es hijo de StageConstructorView, al cambiar a StageSimulatorView (Handoff), el Bridge SE DESMONTA y deja de sincronizar justo cuando m√°s lo necesitamos."

---

## üî¨ INVESTIGACI√ìN FORENSE

### üéØ SOSPECHOSO #1: UBICACI√ìN DEL PUENTE

**ARCHIVO:** `src/App.tsx`  
**L√çNEAS CR√çTICAS:** 68-69

```tsx
return (
  <div className="app-container">
    {/* üåâ WAVE 377: Invisible Sync Bridge - stageStore ‚Üí Backend */}
    <TitanSyncBridge />
    
    {/* Header - Status Bar (FIJO) */}
    <Header />
    
    {/* Main Content */}
    <main className="main-content">
      {/* ... */}
    </main>
  </div>
)
```

### ‚úÖ VEREDICTO #1: **INOCENTE**

**HALLAZGO:**
- TitanSyncBridge est√° montado en **App.tsx** (nivel ra√≠z)
- **NO es hijo de StageConstructorView**
- **PERSISTE** durante todo el ciclo de vida de la app
- **NO se desmonta** al cambiar de Constructor ‚Üí Simulate

**IMPLICACI√ìN:**
La hip√≥tesis del desmontaje es **DESCARTADA**. El Bridge est√° **SIEMPRE VIVO**.

---

### üéØ SOSPECHOSO #2: ESTADO INICIAL DE CARGA

**ARCHIVO:** `src/core/sync/TitanSyncBridge.tsx`  
**L√çNEAS CR√çTICAS:** 136-160

```tsx
useEffect(() => {
  console.log('[TitanSyncBridge] üåâ Bridge ONLINE - subscribing to fixtures (WAVE 378.6)')
  
  // Subscribe to store changes OUTSIDE of React's render cycle
  const unsubscribe = useStageStore.subscribe(
    (state) => state.fixtures,
    (fixtures, prevFixtures) => {
      // Generate hash to detect actual content changes
      const currentHash = generateFixturesHash(fixtures)
      
      // Skip if no actual change
      if (currentHash === lastSyncedHashRef.current) {
        return
      }
      
      // Debounce the sync
      debounceTimeoutRef.current = setTimeout(() => {
        lastSyncedHashRef.current = currentHash
        console.log(`[TitanSyncBridge] üåâ Fixtures changed (${fixtures.length}) ‚Üí syncing...`)
        syncToBackend(fixtures)
      }, SYNC_DEBOUNCE_MS)
    },
    { fireImmediately: true } // ‚ö†Ô∏è CRITICAL OPTION
  )
  
  return () => {
    console.log('[TitanSyncBridge] üåâ Bridge OFFLINE')
    unsubscribe()
  }
}, [])
```

### ‚úÖ VEREDICTO #2: **INOCENTE**

**HALLAZGO:**
- `{ fireImmediately: true }` est√° presente
- Zustand **DISPARA** el callback en cuanto se suscribe
- Si `stageStore.fixtures` tiene datos al montar el Bridge, **SE SINCRONIZA INMEDIATAMENTE**

**IMPLICACI√ìN:**
El Bridge **S√ç deber√≠a sincronizar** al arrancar la app, incluso si los fixtures se cargan de disco ANTES de que App.tsx monte.

---

### üéØ SOSPECHOSO #3: EL "SAFETY GUARD" DEL ARBITER

**ARCHIVO:** `src/core/sync/TitanSyncBridge.tsx`  
**L√çNEAS CR√çTICAS:** 75-115

```tsx
const syncToBackend = async (fixtureList: any[]) => {
  // Check if window.lux exists (Electron environment)
  const lux = (window as any).lux
  
  if (!lux) {
    console.warn('[TitanSyncBridge] ‚ö†Ô∏è window.lux not available')
    return  // ‚ùå SILENT FAILURE
  }
  
  // Convert stageStore fixtures to ArbiterFixture format
  const arbiterFixtures = fixtureList.map(f => {
    const type = (f.type || '').toLowerCase()
    const hasMovementChannels = type.includes('moving') || 
                                type.includes('spot') || 
                                type.includes('beam') ||
                                Boolean(f.capabilities?.hasMovement)
    
    return {
      id: f.id,
      name: f.name || f.id,
      dmxAddress: f.dmxAddress,
      universe: f.universe || 0,
      zone: f.zone || 'UNASSIGNED',
      type: f.type || 'generic',
      channels: f.channels || [],
      capabilities: f.capabilities || {},
      hasMovementChannels,
      position: f.position,
      rotation: f.rotation,
    }
  })
  
  try {
    if (lux.arbiter?.setFixtures) {
      await lux.arbiter.setFixtures(arbiterFixtures)
      console.log(`[TitanSyncBridge] ‚úÖ Synced ${arbiterFixtures.length} fixtures to Arbiter`)
    } else {
      console.warn('[TitanSyncBridge] ‚ö†Ô∏è lux.arbiter.setFixtures not available')
      // ‚ùå SILENT FAILURE
    }
  } catch (err) {
    console.warn('[TitanSyncBridge] ‚ö†Ô∏è Backend sync failed:', err)
    // ‚ùå SILENT FAILURE (catch swallows error)
  }
}
```

### üî¥ VEREDICTO #3: **CULPABLE** (POTENCIAL)

**HALLAZGOS:**

#### üü° RIESGO ALTO: Race Condition en `window.lux`

**PROBLEMA:**
```
App.tsx mount (React render cycle)
    ‚Üì
TitanSyncBridge mount (useEffect ejecuta)
    ‚Üì
Zustand subscribe fires IMMEDIATELY
    ‚Üì
syncToBackend() ejecuta
    ‚Üì
window.lux check ‚Üí ‚ùå PUEDE SER UNDEFINED
```

**TIMING CR√çTICO:**
- `window.lux` se define en `electron/preload.ts`
- Se inyecta **ANTES** de que el DOM cargue (contextBridge)
- **PERO** App.tsx puede montar antes de que Electron est√© listo

**ESCENARIO DE FALLO:**
1. React monta App.tsx en < 50ms
2. TitanSyncBridge se suscribe inmediatamente
3. `window.lux` a√∫n no existe (Electron contexto no ready)
4. `syncToBackend()` hace early return **SIN LOGEAR**
5. **Frontend tiene fixtures, Backend no los recibe**

#### üü° RIESGO MEDIO: Silent Failure en `lux.arbiter?.setFixtures`

**PROBLEMA:**
```typescript
if (lux.arbiter?.setFixtures) {
  await lux.arbiter.setFixtures(arbiterFixtures)
} else {
  console.warn('[TitanSyncBridge] ‚ö†Ô∏è lux.arbiter.setFixtures not available')
  // ‚ùå NO REINTENTA, NO LOGEA EN OTRO LADO
}
```

Si `lux.arbiter.setFixtures` no est√° disponible:
- Se logea warning en console
- **PERO** no hay retry logic
- **PERO** no hay notificaci√≥n al usuario
- **FIXTURES NUNCA SE SINCRONIZAN**

#### üü° RIESGO MEDIO: Error Swallowing

**PROBLEMA:**
```typescript
try {
  await lux.arbiter.setFixtures(arbiterFixtures)
} catch (err) {
  console.warn('[TitanSyncBridge] ‚ö†Ô∏è Backend sync failed:', err)
  // ‚ùå ERROR CAUGHT BUT NOT RE-THROWN
}
```

Si el IPC falla (timeout, IPC channel closed, backend crash):
- Error se logea
- **PERO** error se SWALLOW (no se propaga)
- **PERO** usuario no sabe que fall√≥

---

## üîç AN√ÅLISIS DE FLUJO DE DATOS

### üì° FLUJO ESPERADO (Happy Path):

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 1. App.tsx mount                                       ‚îÇ
‚îÇ    - TitanSyncBridge mount                             ‚îÇ
‚îÇ    - useEffect ejecuta                                 ‚îÇ
‚îÇ    - Zustand.subscribe() registra listener             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚îÇ
                     ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 2. Zustand fires IMMEDIATELY (fireImmediately: true)   ‚îÇ
‚îÇ    - callback ejecuta con fixtures actuales            ‚îÇ
‚îÇ    - generateFixturesHash() calcula hash               ‚îÇ
‚îÇ    - Hash != lastSyncedHashRef (primera vez)           ‚îÇ
‚îÇ    - setTimeout() arranca (500ms debounce)             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚îÇ (500ms delay)
                     ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 3. syncToBackend() ejecuta                             ‚îÇ
‚îÇ    - window.lux check ‚Üí ‚úÖ EXISTS                      ‚îÇ
‚îÇ    - lux.arbiter.setFixtures check ‚Üí ‚úÖ EXISTS         ‚îÇ
‚îÇ    - IPC call: lux:arbiter:setFixtures                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚îÇ
                     ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 4. Backend (ArbiterIPCHandlers.ts)                     ‚îÇ
‚îÇ    - ipcMain.handle('lux:arbiter:setFixtures')         ‚îÇ
‚îÇ    - masterArbiter.setFixtures(fixtures)               ‚îÇ
‚îÇ    - orchestrator.setFixtures(fixtures)                ‚îÇ
‚îÇ    - Log: "‚úÖ Synced N fixtures"                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### ‚ö†Ô∏è FLUJO ACTUAL (Failure Path):

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 1. App.tsx mount (React fast render)                   ‚îÇ
‚îÇ    - TitanSyncBridge mount                             ‚îÇ
‚îÇ    - useEffect ejecuta                                 ‚îÇ
‚îÇ    - Zustand.subscribe() registra listener             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚îÇ
                     ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 2. Zustand fires IMMEDIATELY                           ‚îÇ
‚îÇ    - callback ejecuta con fixtures = []                ‚îÇ
‚îÇ    - generateFixturesHash([]) ‚Üí "empty"                ‚îÇ
‚îÇ    - lastSyncedHashRef.current = ""                    ‚îÇ
‚îÇ    - "empty" != "" ‚Üí setTimeout()                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚îÇ (500ms delay)
                     ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 3. syncToBackend([]) ejecuta                           ‚îÇ
‚îÇ    - window.lux check ‚Üí ‚ùì PUEDE SER UNDEFINED         ‚îÇ
‚îÇ    - IF undefined:                                     ‚îÇ
‚îÇ      ‚Üí console.warn() [usuario no ve]                  ‚îÇ
‚îÇ      ‚Üí return (SILENT FAILURE)                         ‚îÇ
‚îÇ    - IF defined pero IPC no ready:                     ‚îÇ
‚îÇ      ‚Üí catch block (SILENT FAILURE)                    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚îÇ
                     ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 4. StagePersistence.loadShow() ejecuta (DESPU√âS)       ‚îÇ
‚îÇ    - Lee JSON de disco                                 ‚îÇ
‚îÇ    - stageStore.setFixtures(loadedFixtures)            ‚îÇ
‚îÇ    - Zustand notifica cambio                           ‚îÇ
‚îÇ    - Bridge callback ejecuta OTRA VEZ                  ‚îÇ
‚îÇ    - PERO lastSyncedHashRef ya tiene hash              ‚îÇ
‚îÇ    - Hash MATCH ‚Üí early return (NO SYNC!)              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### üî¥ SMOKING GUN: TIMING RACE

**SECUENCIA FATAL:**

1. **T=0ms:** App.tsx mount
2. **T=10ms:** TitanSyncBridge mount + subscribe
3. **T=11ms:** Zustand fires con `fixtures = []` (store vac√≠o)
4. **T=12ms:** Hash calculado = "empty"
5. **T=512ms:** syncToBackend([]) ejecuta ‚Üí Backend recibe 0 fixtures
6. **T=800ms:** StagePersistence carga show de disco
7. **T=801ms:** stageStore.setFixtures([10 fixtures])
8. **T=802ms:** Zustand notifica cambio
9. **T=803ms:** Bridge callback ejecuta
10. **T=804ms:** Hash calculado = "fix1:1:0:front:moving|..."
11. **T=805ms:** Hash COMPARE con lastSyncedHashRef
12. **‚ùå PROBLEMA:** lastSyncedHashRef = "empty" (del primer sync)
13. **‚úÖ PARECE QUE DEBER√çA SYNC:** Hash diferente ‚Üí deber√≠a ejecutar setTimeout()
14. **ü§î PERO SI NO EST√Å SYNCEANDO:** Hay otro problema en el c√≥digo

---

## üéØ HIP√ìTESIS DE FALLO

### üî¥ HIP√ìTESIS A: Race Condition en window.lux

**ESCENARIO:**
```
TitanSyncBridge mount ‚Üí subscribe ‚Üí fireImmediately
    ‚Üì
syncToBackend() ejecuta ANTES de que window.lux exista
    ‚Üì
Early return sin logear
    ‚Üì
Backend nunca recibe fixtures
```

**EVIDENCIA:**
- L√≠nea 78: `if (!lux) { console.warn(...); return }`
- Si esto ejecuta en los primeros 50ms de mount, window.lux puede no existir

**PRUEBA:**
Checkear logs del Browser Console al arrancar la app:
- ¬øAparece `[TitanSyncBridge] ‚ö†Ô∏è window.lux not available`?
- ¬øAparece `[TitanSyncBridge] ‚ö†Ô∏è lux.arbiter.setFixtures not available`?

### üî¥ HIP√ìTESIS B: Fixtures Cargan DESPU√âS del Primer Sync

**ESCENARIO:**
```
TitanSyncBridge mount ‚Üí subscribe ‚Üí fixtures = [] (store vac√≠o)
    ‚Üì
Sync exitoso con 0 fixtures
    ‚Üì
lastSyncedHashRef.current = "empty"
    ‚Üì
StagePersistence carga show ‚Üí stageStore.setFixtures([10])
    ‚Üì
Zustand notifica ‚Üí Bridge callback
    ‚Üì
‚ùå BUG: Hash NO SE RECALCULA correctamente
```

**EVIDENCIA:**
Verificar si `generateFixturesHash()` tiene bug:
```typescript
const generateFixturesHash = (fixtureList: any[]): string => {
  if (!fixtureList || fixtureList.length === 0) return 'empty'
  
  return fixtureList
    .map(f => `${f.id}:${f.dmxAddress}:${f.universe}:${f.zone}:${f.type}`)
    .sort()
    .join('|')
}
```

Este c√≥digo parece correcto, pero:
- ¬øQu√© pasa si `fixtureList` tiene fixtures pero algunos campos son `undefined`?
- ¬øEl hash incluye TODOS los campos relevantes? (NO incluye channels, capabilities)

### üî¥ HIP√ìTESIS C: IPC Handler No Registrado

**ESCENARIO:**
```
TitanSyncBridge llama lux.arbiter.setFixtures()
    ‚Üì
Electron preload expone la funci√≥n
    ‚Üì
‚ùå Backend NO tiene handler registrado para 'lux:arbiter:setFixtures'
    ‚Üì
IPC call timeout / silent failure
```

**EVIDENCIA:**
Verificar en `electron/main.ts` o `src/core/arbiter/ArbiterIPCHandlers.ts`:
- ¬øSe llama `registerArbiterHandlers()` al arrancar?
- ¬øEl handler 'lux:arbiter:setFixtures' est√° registrado?

---

## üîß PLAN DE DIAGN√ìSTICO INMEDIATO

### üìã CHECKLIST DE VERIFICACI√ìN

#### ‚úÖ PASO 1: Verificar Logs del Bridge

**ACCI√ìN:**
1. Arrancar la app con DevTools abierto (Console tab)
2. Buscar logs de TitanSyncBridge:

```
[TitanSyncBridge] üåâ Bridge ONLINE - subscribing to fixtures (WAVE 378.6)
[TitanSyncBridge] üåâ Fixtures changed (N) ‚Üí syncing...
[TitanSyncBridge] ‚úÖ Synced N fixtures to Arbiter
```

**DIAGN√ìSTICO:**
- ‚ùå **NO aparece "Bridge ONLINE"** ‚Üí Component no se monta (imposible, est√° en App.tsx)
- ‚ùå **NO aparece "Fixtures changed"** ‚Üí Zustand subscription no dispara
- ‚ùå **NO aparece "Synced N fixtures"** ‚Üí syncToBackend() falla silenciosamente
- ‚ö†Ô∏è **Aparece "window.lux not available"** ‚Üí Race condition confirmado
- ‚ö†Ô∏è **Aparece "lux.arbiter.setFixtures not available"** ‚Üí IPC handler no registrado

#### ‚úÖ PASO 2: Verificar Timing de window.lux

**ACCI√ìN:**
1. Agregar log al inicio de `syncToBackend()`:

```typescript
const syncToBackend = async (fixtureList: any[]) => {
  console.log(`[TitanSyncBridge] üîç syncToBackend called with ${fixtureList.length} fixtures`)
  console.log(`[TitanSyncBridge] üîç window.lux exists:`, typeof (window as any).lux !== 'undefined')
  console.log(`[TitanSyncBridge] üîç lux.arbiter exists:`, typeof (window as any).lux?.arbiter !== 'undefined')
  console.log(`[TitanSyncBridge] üîç lux.arbiter.setFixtures exists:`, typeof (window as any).lux?.arbiter?.setFixtures === 'function')
  
  // ... rest of function
}
```

2. Arrancar app y verificar logs

**DIAGN√ìSTICO:**
- ‚ùå `window.lux exists: false` ‚Üí Race condition, TitanSyncBridge ejecuta antes de que preload inyecte lux
- ‚ùå `lux.arbiter exists: false` ‚Üí Arbiter no se exporta en preload
- ‚ùå `lux.arbiter.setFixtures exists: false` ‚Üí IPC handler no est√° registrado

#### ‚úÖ PASO 3: Verificar Hash Changes

**ACCI√ìN:**
1. Agregar logs en el callback de Zustand:

```typescript
const unsubscribe = useStageStore.subscribe(
  (state) => state.fixtures,
  (fixtures, prevFixtures) => {
    const currentHash = generateFixturesHash(fixtures)
    const lastHash = lastSyncedHashRef.current
    
    console.log(`[TitanSyncBridge] üîç Fixtures changed:`)
    console.log(`  - Count: ${fixtures.length}`)
    console.log(`  - Current Hash: ${currentHash}`)
    console.log(`  - Last Hash: ${lastHash}`)
    console.log(`  - Will Sync: ${currentHash !== lastHash}`)
    
    if (currentHash === lastSyncedHashRef.current) {
      console.log(`[TitanSyncBridge] ‚è≠Ô∏è Hash unchanged, skipping sync`)
      return
    }
    
    // ... rest of callback
  }
)
```

**DIAGN√ìSTICO:**
- ‚ùå `Will Sync: false` cuando fixtures cambian ‚Üí Hash bug
- ‚ùå `Count: 0` siempre ‚Üí Store no se actualiza
- ‚ùå `Current Hash === Last Hash` despu√©s de cargar show ‚Üí Hash collision

#### ‚úÖ PASO 4: Verificar IPC Handler Registration

**ACCI√ìN:**
1. Buscar en c√≥digo d√≥nde se registra `lux:arbiter:setFixtures`:

```bash
grep -rn "lux:arbiter:setFixtures" electron-app/src electron-app/electron
```

2. Verificar que `registerArbiterHandlers()` se llama en `electron/main.ts`

**DIAGN√ìSTICO:**
- ‚ùå Handler no encontrado ‚Üí IPC channel no existe
- ‚ùå Handler no se llama en main.ts ‚Üí No se registra al arrancar

#### ‚úÖ PASO 5: Test Manual de IPC

**ACCI√ìN:**
1. Abrir DevTools Console
2. Ejecutar comando manual:

```javascript
await window.lux.arbiter.setFixtures([
  {
    id: 'test_fixture',
    name: 'Test Fixture',
    dmxAddress: 1,
    universe: 0,
    zone: 'front',
    type: 'moving head spot',
    channels: ['dimmer', 'pan', 'tilt', 'red', 'green', 'blue'],
    capabilities: { hasColor: true, hasDimmer: true, hasMovement: true },
    hasMovementChannels: true,
  }
])
```

3. Verificar logs en Terminal (Electron backend)

**DIAGN√ìSTICO:**
- ‚úÖ Log aparece en Terminal ‚Üí IPC funciona, problema es en timing/hash
- ‚ùå Error "Cannot read property 'setFixtures'" ‚Üí window.lux no existe
- ‚ùå Timeout / No response ‚Üí IPC handler no registrado

---

## üîß SOLUCIONES PROPUESTAS

### üéØ FIX #1: Retry Logic en window.lux

**PROBLEMA:** Race condition - window.lux puede no existir al primer sync

**SOLUCI√ìN:**
```typescript
const syncToBackend = async (fixtureList: any[], retryCount = 0): Promise<void> => {
  const MAX_RETRIES = 3
  const RETRY_DELAY = 100 // ms
  
  const lux = (window as any).lux
  
  if (!lux) {
    if (retryCount < MAX_RETRIES) {
      console.warn(`[TitanSyncBridge] ‚ö†Ô∏è window.lux not ready, retrying in ${RETRY_DELAY}ms (attempt ${retryCount + 1}/${MAX_RETRIES})`)
      await new Promise(resolve => setTimeout(resolve, RETRY_DELAY))
      return syncToBackend(fixtureList, retryCount + 1)
    } else {
      console.error('[TitanSyncBridge] ‚ùå window.lux not available after retries')
      return
    }
  }
  
  // ... rest of function
}
```

**BENEFICIO:**
- Tolera race conditions al arrancar
- Da tiempo a que Electron contexto est√© listo
- Falla gracefully despu√©s de 3 intentos

### üéØ FIX #2: Explicit IPC Ready Check

**PROBLEMA:** No sabemos si el backend est√° listo

**SOLUCI√ìN:**
```typescript
// En TitanSyncBridge.tsx
useEffect(() => {
  console.log('[TitanSyncBridge] üåâ Bridge ONLINE - waiting for backend ready...')
  
  // Wait for backend to be ready
  const checkBackendReady = async () => {
    const lux = (window as any).lux
    
    if (!lux || !lux.arbiter?.setFixtures) {
      console.log('[TitanSyncBridge] ‚è≥ Backend not ready, waiting...')
      await new Promise(resolve => setTimeout(resolve, 100))
      return checkBackendReady()
    }
    
    console.log('[TitanSyncBridge] ‚úÖ Backend ready, subscribing to fixtures')
    
    // NOW subscribe to store
    const unsubscribe = useStageStore.subscribe(
      (state) => state.fixtures,
      (fixtures) => {
        // ... sync logic
      },
      { fireImmediately: true }
    )
    
    return unsubscribe
  }
  
  let unsubscribe: (() => void) | undefined
  
  checkBackendReady().then(unsub => {
    unsubscribe = unsub
  })
  
  return () => {
    unsubscribe?.()
  }
}, [])
```

**BENEFICIO:**
- Garantiza que IPC est√© listo antes de suscribirse
- Evita race conditions por completo
- Log claro de cu√°ndo backend est√° listo

### üéØ FIX #3: Hash Includes All Relevant Fields

**PROBLEMA:** Hash no incluye channels/capabilities ‚Üí cambios no detectados

**SOLUCI√ìN:**
```typescript
const generateFixturesHash = (fixtureList: any[]): string => {
  if (!fixtureList || fixtureList.length === 0) return 'empty'
  
  return fixtureList
    .map(f => {
      const channelsHash = f.channels?.length ? `:ch${f.channels.length}` : ''
      const capsHash = f.capabilities ? `:caps${JSON.stringify(f.capabilities)}` : ''
      return `${f.id}:${f.dmxAddress}:${f.universe}:${f.zone}:${f.type}${channelsHash}${capsHash}`
    })
    .sort()
    .join('|')
}
```

**BENEFICIO:**
- Detecta cambios en channels/capabilities
- Previene hash collisions
- M√°s robusto para futuros cambios

### üéØ FIX #4: User Notification on Sync Failure

**PROBLEMA:** Errores son silent ‚Üí usuario no sabe que fall√≥

**SOLUCI√ìN:**
```typescript
const syncToBackend = async (fixtureList: any[]) => {
  const lux = (window as any).lux
  
  if (!lux) {
    console.error('[TitanSyncBridge] ‚ùå window.lux not available')
    // Notify user via UI
    useLuxSyncStore.getState().addLog({
      level: 'error',
      message: 'Failed to sync fixtures to backend: Electron IPC not ready'
    })
    return
  }
  
  try {
    if (lux.arbiter?.setFixtures) {
      await lux.arbiter.setFixtures(arbiterFixtures)
      console.log(`[TitanSyncBridge] ‚úÖ Synced ${arbiterFixtures.length} fixtures to Arbiter`)
    } else {
      throw new Error('lux.arbiter.setFixtures not available')
    }
  } catch (err) {
    console.error('[TitanSyncBridge] ‚ùå Backend sync failed:', err)
    // Notify user via UI
    useLuxSyncStore.getState().addLog({
      level: 'error',
      message: `Failed to sync ${arbiterFixtures.length} fixtures: ${err}`
    })
    // Re-throw to propagate error
    throw err
  }
}
```

**BENEFICIO:**
- Usuario sabe si sync fall√≥
- Logs visible en Tactical Log
- Facilita debugging en producci√≥n

---

## üìã CONCLUSIONES

### ‚úÖ ARQUITECTURA CORRECTA

- TitanSyncBridge **BIEN UBICADO** en App.tsx (ra√≠z)
- **NO se desmonta** al cambiar vistas
- `fireImmediately: true` **CORRECTO** para sync en mount

### üî¥ PROBLEMAS DETECTADOS

| Issue | Severity | Impact | Likelihood |
|-------|----------|--------|------------|
| Race condition en window.lux | üî¥ CR√çTICO | Backend nunca recibe fixtures | 80% |
| Silent failure sin retry | üî¥ CR√çTICO | Sin recovery autom√°tico | 100% |
| Hash no incluye channels/caps | üü° MEDIO | Cambios no detectados | 30% |
| Error swallowing | üü° MEDIO | Usuario no sabe que fall√≥ | 100% |

### üéØ PR√ìXIMOS PASOS

#### üî• URGENTE (Esta Sesi√≥n):

1. **Agregar logs de diagn√≥stico** (Paso 2 del checklist)
2. **Test manual de IPC** (Paso 5 del checklist)
3. **Verificar registration de handlers** (Paso 4 del checklist)

#### üü° IMPORTANTE (Esta Semana):

4. **Implementar FIX #2** (Backend ready check)
5. **Implementar FIX #1** (Retry logic)
6. **Implementar FIX #4** (User notification)

#### üü¢ NICE TO HAVE (Cuando Haya Tiempo):

7. **Implementar FIX #3** (Hash mejorado)
8. **Agregar health check** (ping backend cada 10s)
9. **Telemetr√≠a de sync** (track √©xito/failure rate)

---

## üìú VEREDICTO FINAL

**EL PUENTE NO ES SILENCIOSO, ES CIEGO.**

El TitanSyncBridge est√° **VIVO** y **INTENTANDO SINCRONIZAR**, pero:
1. Puede estar disparando **ANTES** de que window.lux exista (race condition)
2. Falla **SILENCIOSAMENTE** sin retry ni notificaci√≥n
3. Usuario no sabe que el sync fall√≥ hasta que intenta ejecutar el show

**RECOMENDACI√ìN:**
Implementar **FIX #2** (Backend ready check) como prioridad m√°xima. Esto garantiza que el Bridge no intente sincronizar hasta que el backend est√© listo.

---

**PunkOpus & Radwulf**  
*Connectivity Forensics - Enero 14, 2026*  
*Operaci√≥n: THE SILENT BRIDGE - COMPLETADA*  

üîç **EL BRIDGE EST√Å VIVO, PERO NECESITA GAFAS.** üåâ
